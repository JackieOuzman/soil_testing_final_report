---
title: "Summary for final report"
author: "Jackie Ouzman"
date: "08/09/2021"
output: html_document
---
```{r load library, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


library(tidyverse)
library(ggplot2)

library(formattable)
library(sf)
library(readxl)


library(gt)
library(glue)


library(rnaturalearth)


library(readr)

library(DT)
library(plotKML)
library(knitr)
library(png)


library(magick)
library(gridExtra)

```

## Number of N and P trials for 2020 -2021  season 

CSIRO team have been supplied with spatial data for the location of strip trials.
Along with this information we have details on the type of trial (either N or P) and the fertilisers used.



Note that a few paddocks have both N and P trials.



Most paddocks have two zone, but some have just one and some have multiple zone.
This is filtering data out that is marked excluded from analysis and ensured I am only keeping unique Zone ID.

```{r zone shapefile 2020, message=TRUE, warning=FALSE, include=FALSE}
zone2020 <- st_read("W:/value_soil_testing_prj/Yield_data/2020/All_Zones_2020_wgs84.shp")


zone2020_df <- data.frame(zone2020)
zone2020_1 <- zone2020_df %>% dplyr::select(-geometry)


## some paddocks are excluded from the analysis
zone2020_df <- zone2020_1 %>% 
  filter(Status != "Excluded from Analysis")
#just keep a few clms
names(zone2020_df)
zone2020_df <- zone2020_df %>% 
  dplyr::select(Zone_ID,
                Strip_Type,
                Status,
                organisati,
                contact, 
                farmer,
                paddock)
rm(zone2020, zone2020_1)


zone2020_unique <- zone2020_df %>% 
  distinct(Zone_ID, Strip_Type, .keep_all = TRUE)

#how many zones with N / P strips?
zone2020_count <- zone2020_unique %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>%
  group_by(Strip_Type) %>% 
  summarise(count_zones_by_type = n())



```

2020 season. Zone per fertilsier strip type (using zone shapefile).

```{r  numb strip trials, echo=FALSE, message=TRUE, warning=FALSE}

zone2020_count

```

2020 season.Paddocks per fertilsier strip type.

```{r zone 2020 per paddock, message=TRUE, warning=FALSE, include=FALSE}
#how many paddocks with N / P strips?

names(zone2020_unique)
#I cant just select paddock names beacuse some have the same name house and creek

zone_paddocks <- zone2020_unique %>%
  dplyr::mutate(paddock_farmer = paste0(paddock, "_", farmer)) %>% 
  dplyr::distinct(paddock_farmer, Strip_Type, .keep_all = TRUE)
  
zone_paddocks 
 
count_paddock <- zone_paddocks %>% 
  group_by(Strip_Type) %>% 
  summarise(count_paddocks_by_type = n())

```


```{r  numb paddocks, echo=FALSE, message=TRUE, warning=FALSE}

count_paddock


```


2020 season. How many growers?

```{r zone 2020 per farmers, message=TRUE, warning=FALSE, include=FALSE}

farmers_dist <- zone2020_unique %>% 
  dplyr::distinct(farmer,Strip_Type, .keep_all = TRUE)

farmers_count_type <- farmers_dist %>% 
    group_by(Strip_Type) %>% 
  summarise(count_farmers_by_type = n())

farmers_count <- farmers_dist %>% 
    summarise(count_farmers_by_type = n())



```

```{r number of farmers 2020, echo=FALSE, message=TRUE, warning=FALSE}
farmers_count
```


I can run the same analysis with the strip files but the numbers are slightly different because of the trials that have N and P.
So I will use the zone shapefile as a basis.
The code is here but I am not displaying the output.


```{r load_data1, message=TRUE, warning=FALSE, include=FALSE}

#note that this script runs off the shapefile and has on intermediate steps


spatial_data_no_yld <- st_read("W:/value_soil_testing_prj/Yield_data/2020/All_Strips_2020_wgs84.shp")

spatial <-  st_as_sf(spatial_data_no_yld, coords = c("X", "Y"), crs = 4326) #this is for map in later code chuck

spatial_data_no_yld_df <- data.frame(spatial_data_no_yld)
spatial_data_no_yld_df_1 <- spatial_data_no_yld_df %>% dplyr::select(-geometry)

## some paddocks are excluded from the analysis
spatial_data_no_yld_df <- spatial_data_no_yld_df_1 %>% 
   filter(Status != "Excluded from Analysis")

spatial_data_no_yld_df <- spatial_data_no_yld_df %>% 
  dplyr::mutate(ID_Rate_GSP_type = paste0(Paddock_ID, "-", Rate, "-", GSP,"-",Strip_Type ),
         ID_trial_type = paste0(Paddock_ID, "-",Strip_Type))

spatial_data_no_yld_df <-spatial_data_no_yld_df %>% 
  dplyr::mutate(Alt_GSP = ifelse(stringr::str_detect(GSP_list, "Alt GSP"), "Alt_GPS", "No_Alt_GSP"))

rm(spatial_data_no_yld_df_1)

strips_distinct_paddockID <- spatial_data_no_yld_df %>% 
  distinct(Paddock_ID, Strip_Type, .keep_all = TRUE)

```

```{r plot numb trials, message=TRUE, warning=FALSE, include=FALSE}
plot1 <-
  dplyr::distinct(strips_distinct_paddockID, Paddock_ID ,Strip_Type, .keep_all = TRUE) %>%
  dplyr::select(Paddock_ID, Strip_Type, Alt_GSP) %>%
  ggplot(aes(Strip_Type)) +
  geom_bar() +
  theme_bw() +
  geom_text(aes(y = ((..count..)), label = ((..count..))), stat = "count", vjust = -0.25) +
  labs(
    title = "Number of P and N trials. 2020 to 2021 season",
    y = "Count",
    x = "Type of trial",
    subtitle = paste0("Total number of paddocks = ", count(
      distinct(spatial_data_no_yld_df, ID_trial_type)
    ))
  )
plot1


```




## Number of N and P trials for 2019 -2020  season 

```{r zone shapefile 2019, message=TRUE, warning=FALSE, include=FALSE}
zone2019 <- st_read("W:/value_soil_testing_prj/Yield_data/finished/GIS_Results/All_Zones_2019_wgs84.shp")


zone2019_df <- data.frame(zone2019)
zone2019_1 <- zone2019_df %>% dplyr::select(-geometry)


## some paddocks are excluded from the analysis

#just keep a few clms

zone2019_df <- zone2019_1 %>% 
  dplyr::select(Zone_ID,
                Strip_Type, # I need to add this in ??
                #Status,
                organisati,
                contact, 
                farmer,
                paddock)
rm(zone2019, zone2019_1)


zone2019_df_unique <- zone2019_df %>% 
  distinct(Zone_ID, Strip_Type, .keep_all = TRUE)

#how many zones with N / P strips?
zone2019_count <- zone2019_df_unique %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>%
  group_by(Strip_Type) %>% 
  summarise(count_zones_by_type = n())



```

2019 season. Zone per fertilsier strip type (using zone shapefile).

```{r  numb strip trials 2019, echo=FALSE, message=TRUE, warning=FALSE}

zone2019_count

```

2019 season.Paddocks per fertilsier strip type.

```{r zone 2019 per paddock, message=TRUE, warning=FALSE, include=FALSE}
#how many paddocks with N / P strips?


zone_paddocks2019 <- zone2019_df_unique %>%
  dplyr::mutate(paddock_farmer = paste0(paddock, "_", farmer)) %>% 
  dplyr::distinct(paddock_farmer, Strip_Type, .keep_all = TRUE)

paddocks2019 <-  zone_paddocks2019 %>% 
  group_by(Strip_Type) %>% 
  summarise(count_paddocks_by_type = n())


```


```{r  numb paddocks 2019, echo=FALSE, message=TRUE, warning=FALSE}

paddocks2019

```


2019 season. How many growers?

```{r zone 2019 per farmers, message=TRUE, warning=FALSE, include=FALSE}


farmers_dist2019 <- zone2019_df_unique %>% 
  dplyr::distinct(farmer,Strip_Type, .keep_all = TRUE)

farmers_count_type2019 <- farmers_dist2019 %>% 
  group_by(Strip_Type) %>% 
  summarise(count_farmers_by_type = n())

farmers_count2019 <- farmers_dist2019 %>% 
  summarise(count_farmers = n())



```

```{r number of farmers 2019, echo=FALSE, message=TRUE, warning=FALSE}

farmers_count_type2019
farmers_count2019
```



I have spent a lot of time getting these two df is good shape.
The next to code chucks reflect this and the two df to use are called:
All_zone_rates_2019
All_zone_rates_2020.

I have also outputted these are csv file.

W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/GM_t.test_details_rec_rates2019.csv
W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/GM_t.test_details_rec_rates2020.csv


```{r stuff around getting recom rates just for our 2020 paddocks, message=TRUE, warning=FALSE, include=FALSE}


#Get this from the scrap notes 4 should be 2 files.
# I will add the code in here but for now I will just use this file
##########################################################################################################
##### scrap_notes4_2020.R
##########################################################################################################

## getting the yield difference and GM difference between GSP and Approx

all_strips2020 <- st_read("W:/value_soil_testing_prj/Yield_data/2020/All_Strips_2020_wgs84.shp")
#names(all_strips2020)
all_strips2020 <- all_strips2020 %>%
  dplyr::select(Paddock_ID, geometry, 
                Organisation = organisati,
                Contact = contact,
                Farmer = farmer,
                Paddock_tested = paddock,
                Status) 
### remove the paddocks with no reports
#unique(all_strips2020$Status)

all_strips2020 <- all_strips2020 %>%
  dplyr::filter(Status != "Excluded from Analysis")

#2.turn polygons into points - centriod
all_strips2020_centroid = st_centroid(all_strips2020)
all_strips2020_centroid <- all_strips2020_centroid %>%  filter(!is.na(Paddock_ID))
#3.
av_rain <- raster::raster("W:/value_soil_testing_prj/Yield_data/2020/processing/rain_grid")

##3a. extract strips coordinates points from the raster (eg shapefile points and average rainfall grid)
all_strips2020_centroid$av_rain <- raster::extract(av_rain, all_strips2020_centroid)
all_strips2020_centroid_df <- as.data.frame(all_strips2020_centroid ) %>%  dplyr::select(-geometry)
rm(all_strips2020, all_strips2020_centroid, av_rain)


## add in GRDC zone
zone2020_GRDC_bound <- st_read("W:/value_soil_testing_prj/Yield_data/2020/2020_GRDC_zones_test.shp")


zone2020_GRDC_bound <- zone2020_GRDC_bound %>% 
  dplyr::select(Zone_ID,
                AGROECOLOG)
zone2020_GRDC_bound <- as.data.frame(zone2020_GRDC_bound) %>% 
  dplyr::select(- geometry)
##make a paddock_ID clm
zone2020_GRDC_bound$length_zoneID <- nchar(zone2020_GRDC_bound$Zone_ID)
zone2020_GRDC_bound <- zone2020_GRDC_bound %>% 
  mutate(Paddock_ID =   
           case_when(length_zoneID == 6 ~ substr(Zone_ID, start = 1, stop = 5),
                     length_zoneID == 7 ~ substr(Zone_ID, start = 1, stop = 6)))
zone2020_GRDC_bound$Paddock_ID <- as.double(zone2020_GRDC_bound$Paddock_ID)

# str(zone2020_GRDC_bound)
# str(all_strips2020_centroid_df)

all_strips2020_centroid_df <- left_join(all_strips2020_centroid_df, zone2020_GRDC_bound)
all_strips2020_centroid_df <- all_strips2020_centroid_df %>% 
  dplyr::mutate(
    rainfall_class = case_when(
      av_rain<=350 ~ "low",
      av_rain >500 ~ "high",
      TRUE ~ "medium"))

#names(all_strips2020_centroid_df)
all_strips2020_centroid_df <- all_strips2020_centroid_df %>% 
  dplyr::select( Paddock_ID,
                 Organisation,
                 Contact,
                 Farmer,Paddock_tested,
                 AGROECOLOG, 
                 rainfall_class) 

### oops I need the rates from the fert df

fertiliser_applied2020 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/step2_fert_app_all_steps.csv")
#str(fertiliser_applied2020)

fert_2020 <- fertiliser_applied2020 %>% 
  dplyr::select(Paddock_ID, Rate,GSP,Strip_Type,
                Total_sum_N_content,
                Total_sum_P_content) 

rm(fertiliser_applied2020, zone2020_GRDC_bound)
#str(all_strips2020_centroid_df)
#str(fert_2020)
## add it to the other data

details_2020 <- left_join(fert_2020, all_strips2020_centroid_df)
rm(fert_2020,all_strips2020_centroid_df )

#names(details_2020)




## Not sure if there is dupliaction only want paddock ID, strip type and rate

### need to remove the Alt GSP here..
details_2020 <- details_2020 %>% 
  filter(GSP == "GSP" | is.na(GSP))

details_2020 <- details_2020 %>% 
  dplyr::distinct(Paddock_ID, Strip_Type, Rate, .keep_all = TRUE)

### fix up some problems paddock 52355 has a rate of 82.5 and should be 82

details_2020 <- details_2020 %>% 
  mutate(Rate = case_when(
    Paddock_ID == 52355 & Rate == 82.5 ~ 82,
    TRUE ~ as.double(Rate )))
# this one only had a mud map made remove from analysis
details_2020 <- details_2020 %>% 
  filter(Paddock_ID != 52341)
## I had some strange label in the shapefile
details_2020 <- details_2020 %>% 
  mutate(Rate = case_when(
    Paddock_ID == 52411 & Rate == 400 ~ 9.6,
    Paddock_ID == 52411 & Rate == 800 ~ 19.2,
    Paddock_ID == 52411 & Rate == 8050 ~ 42.2,
    Paddock_ID == 52411 & Rate == 80150 ~ 88.2,
    TRUE ~ as.double(Rate )))

details_2020 <- details_2020 %>% 
  mutate(Rate = case_when(
    Paddock_ID == 524102 & Rate == 33 ~ 3.3,
    Paddock_ID == 524102 & Rate == 5033 ~ 21.0,
    Paddock_ID == 524102 & Rate == 435033 ~ 40.78,
    Paddock_ID == 524102 & Rate == 875033 ~ 61.02,
    Paddock_ID == 524102 & Rate == 1305033 ~ 80.8,
    TRUE ~ as.double(Rate )))

#######################################################################################

## bring in the t.test data results

set1_2020 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/r_outputs/merged_comparision_output/t_test_merged_3a.csv")

#names(set1_2020)
set1_2020 <- set1_2020 %>% 
  dplyr::select(Zone_ID,
                Rates = Rate,
                Yld = yield,
                P_value,
                Mean_diff,
                rounded,Significant,
                paddock_ID_Type)

t.test_2020 <- set1_2020


##make a paddock_ID clm
t.test_2020$length_zoneID <- nchar(t.test_2020$Zone_ID)
t.test_2020 <- t.test_2020 %>% 
  mutate(Paddock_ID =   
           case_when(length_zoneID == 6 ~ substr(Zone_ID, start = 1, stop = 5),
                     length_zoneID == 7 ~ substr(Zone_ID, start = 1, stop = 6)))
t.test_2020$Paddock_ID <- as.double(t.test_2020$Paddock_ID)

t.test_2020 <- t.test_2020 %>%  
  mutate(part1=str_split_fixed(paddock_ID_Type,"_",2)[,1], Strip_Type=str_split_fixed(paddock_ID_Type,"_",2)[,2])
t.test_2020 <- t.test_2020 %>%
  dplyr::select(- part1)


## I want to join details_2019 to t.test 

# str(t.test_2020)
# str(details_2020)

t.test_2020 <- t.test_2020 %>% 
  dplyr::mutate(for_join = paste0(Paddock_ID, Strip_Type, Rates))

details_2020 <- details_2020 %>% 
  dplyr::mutate(for_join = paste0(Paddock_ID, Strip_Type, Rate))

t.test2020_details <- full_join(details_2020, t.test_2020)
names(t.test2020_details)


## drop the ones that seem to be exluded from analysis ie no conatct
t.test2020_details <- t.test2020_details %>% 
  filter(!is.na(Contact))






t.test2020_details <- t.test2020_details %>%
  dplyr::select(Zone_ID,
                Paddock_ID,
                Strip_Type,
                Rate,
                GSP,
                Strip_Type,
                Total_sum_N_content,
                Total_sum_P_content,
                Yld,
                Organisation,
                Contact,
                Farmer,
                Paddock_tested,
                rainfall_class,
                AGROECOLOG,
                P_value,
                Mean_diff,
                rounded,
                Significant)
#### This is ready for more the recomm rates



####################################################################################################################################################
## bring in rec rates ##


recom_rateDB2020 <- read_excel( "W:/value_soil_testing_prj/data_base/downloaded_sep2021/GRDC 2020 Paddock Database_SA_VIC_June11 2021.xlsx")
#str(recom_rateDB2020)
# select only a few clms with recommedation 
recom_rateDB2020 <- recom_rateDB2020 %>% 
  dplyr::select(Zone_ID =    `Paddock code` ,
                Total_N = `Total N`, 
                p_rec =           `P rec`,
                n_rec_yld_low =   `N Rec (< 3 t/ha)` ,       
                n_rec_yld_med =   `N Rec (3-5 t/ha)` ,             
                n_rec_yld_high =  `N Rec (> 5 t/ha)`,
                Colwell,
                DGT,
                PBI
                
  ) 

recom_rateDB2020$n_rec_yld_low <- as.double(recom_rateDB2020$n_rec_yld_low)
recom_rateDB2020$n_rec_yld_med <- as.double(recom_rateDB2020$n_rec_yld_med)
recom_rateDB2020$n_rec_yld_high <- as.double(recom_rateDB2020$n_rec_yld_high)
recom_rateDB2020$Colwell <- as.double(recom_rateDB2020$Colwell)
recom_rateDB2020$DGT <- as.double(recom_rateDB2020$DGT)
recom_rateDB2020$PBI <- as.double(recom_rateDB2020$PBI)

recom_rateDB2020 <-  dplyr::mutate(recom_rateDB2020,  maxN = apply(recom_rateDB2020[4:6], 1, max, na.rm = TRUE))


# remove redunant clm and replace inf
recom_rateDB2020 <- recom_rateDB2020 %>% 
  mutate(
    maxN = case_when(
      maxN >= 0 ~ maxN,
      TRUE ~ NA_real_
    )
  )

recom_rateDB2020 <- recom_rateDB2020 %>% 
  dplyr::select(Zone_ID  ,
                p_rec ,
                maxN,
                Total_N,
                Colwell,
                DGT,
                PBI)

##make a paddock_ID clm
recom_rateDB2020$length_zoneID <- nchar(recom_rateDB2020$Zone_ID)
recom_rateDB2020 <- recom_rateDB2020 %>% 
  mutate(Paddock_ID =   
           case_when(length_zoneID == 6 ~ substr(Zone_ID, start = 1, stop = 5),
                     length_zoneID == 7 ~ substr(Zone_ID, start = 1, stop = 6)))
recom_rateDB2020$Paddock_ID <- as.double(recom_rateDB2020$Paddock_ID)



rm(details_2020, t.test_2020)

### join the t.test data to the recom rates
# str(recom_rateDB2020)
# str(t.test2020_details)
recom_rateDB2020$Zone_ID <- as.double(recom_rateDB2020$Zone_ID)
t.test_details_rec_rates <- left_join(t.test2020_details, recom_rateDB2020)
rm(recom_rateDB2020, t.test2020_details)
#############################################################################################################
### Redo the rec rates for N with my rainfall zone

t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(Rec_N_jax = case_when(
    rainfall_class == "low" & Total_N <= 80 ~ ((80 -Total_N)/0.5),
    rainfall_class == "medium" & Total_N <= 160 ~ ((160 -Total_N)/0.5),
    rainfall_class == "high" & Total_N <= 240 ~ ((240 -Total_N)/0.5),
    TRUE                           ~ 0  ))

#str(t.test_details_rec_rates)

# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(critical_colwell = 4.6*( PBI^ (0.393)))
# ## is colwell greater than critical colwell?
# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(colwell_thershold = case_when(
#     Colwell > critical_colwell ~ "adequate",
#     Colwell < critical_colwell ~ "p_required")  )
# 
# ## if p is required how much extra colwell p is needed to get to critical thershold?
# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(to_reach_col_thershold = case_when(
#     colwell_thershold == "p_required" ~ critical_colwell - Colwell))
# 
# ## what is the recomm P rate?
# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(p_rec_jax = case_when(
#     colwell_thershold == "p_required" ~ ((0.0019*PBI+2.146)*to_reach_col_thershold),
#     colwell_thershold == "adequate" ~ 5
#     ))
# ## clean up extra clms
# 
# names(t.test_details_rec_rates)
# 
# t.test_details_rec_rates <- t.test_details_rec_rates %>%
#   dplyr::select(-"length_zoneID",
#                 - critical_colwell,
#                 - colwell_thershold,
#                 - to_reach_col_thershold)


###################################################################################################################################
#write this out 
# write.csv(t.test_details_rec_rates, "W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/t.test_details_rec_rates_2020.csv")


##########################################################################################################
##### scrap_notes4_2020_yld_resposne_economics.R
##########################################################################################################
t.test_details_rec_rates_20 <- t.test_details_rec_rates


#########################################################################################################################################################
### 1. bring in the data
#t.test_details_rec_rates_20 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/t.test_details_rec_rates_2020.csv")
# t.test_details_rec_rates_20 <- t.test_details_rec_rates
#########################################################################################################################################################
### 2. remove the alt GSP
### all of this analysis will be without the Alt GSP so I will remove it
#str(t.test_details_rec_rates_20)

#unique(t.test_details_rec_rates_20$GSP)
t.test_details_rec_rates_20$GSP <- as.character(t.test_details_rec_rates_20$GSP)



#unique(t.test_details_rec_rates_20$GSP)
### difference between p rec and p applied

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(diff_p_rec_applied = abs(Total_sum_P_content- p_rec))
closest_match_p <-t.test_details_rec_rates_20 %>%
  group_by(Zone_ID) %>% 
  summarise(closest_match_p = min(diff_p_rec_applied))


#Add this back in

t.test_details_rec_rates_20 <- left_join(t.test_details_rec_rates_20, closest_match_p)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(rec_rate_approx_p =
           case_when(
             closest_match_p == diff_p_rec_applied ~ "approx_rec_rate"))

unique(t.test_details_rec_rates_20$GSP)
t.test_details_rec_rates_20$GSP <- as.character(t.test_details_rec_rates_20$GSP)

str(t.test_details_rec_rates_20$GSP)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(GSP_Rec_both_p = case_when(
    GSP == "GSP"  & rec_rate_approx_p == "approx_rec_rate" ~ "both",
    is.na(GSP)            & rec_rate_approx_p == "approx_rec_rate" ~ "rec_rate",
    GSP == "GSP"  & is.na(rec_rate_approx_p) ~ "GSP",
    TRUE ~ "other"
  ))


### difference between N rec and N applied
names(t.test_details_rec_rates_20)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(diff_n_rec_applied = abs(Total_sum_N_content- Rec_N_jax))

closest_match_n <-t.test_details_rec_rates_20 %>%
  group_by(Zone_ID) %>% 
  summarise(closest_match_n = min(diff_n_rec_applied))


#Add this back in


t.test_details_rec_rates_20 <- left_join(t.test_details_rec_rates_20, closest_match_n)
str(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(rec_rate_approx_n =
           case_when(
             closest_match_n == diff_n_rec_applied ~ "approx_rec_rate"))



t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(GSP_Rec_both_n = case_when(
    GSP == "GSP"  & rec_rate_approx_n == "approx_rec_rate" ~ "both",
    is.na(GSP)            & rec_rate_approx_n == "approx_rec_rate" ~ "rec_rate",
    GSP == "GSP"  & is.na(rec_rate_approx_n) ~ "GSP",
    TRUE ~ "other"
  ))








#### arrange the data so that I have the order of detail that reflects it.
names(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::select(
    
    #Tier 1
    Paddock_ID,
    Strip_Type,
    Organisation,
    Contact,
    Farmer,
    Paddock_tested,
    rainfall_class,
    AGROECOLOG,
    
    #Tier 2
    Zone_ID,
    Total_N,
    Colwell,
    DGT,
    PBI,
    p_rec,
    maxN,
    Rec_N_jax,
    #p_rec_jax,
    
    #Tier 3
    Rate,
    GSP,
    Total_sum_N_content,
    Total_sum_P_content,
    Yld,
    P_value,
    Mean_diff,
    rounded,
    Significant,
    
    #Tier 3 details# 
    diff_p_rec_applied,
    closest_match_p,
    rec_rate_approx_p,
    GSP_Rec_both_p,
    diff_n_rec_applied,
    closest_match_n,
    rec_rate_approx_n,
    GSP_Rec_both_n
  )    



##############################################################################
### add some GM to yld results 
##############################################################################
# convert the yield to income of grain $/ha
# this assumes that all yield is in t /ha 
# all crops are wheat
# the 5 year wheat average is $286 and is same for all sites.
names(df)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% mutate(grain_income = Yld * 286)

##############################################################################
## cost for test $3 per ha for rates the approx rate here some GSP are also approx rec rate labelled as both

names(t.test_details_rec_rates_20)
unique(t.test_details_rec_rates_20$GSP_Rec_both_p)
unique(t.test_details_rec_rates_20$GSP_Rec_both_n)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% mutate(cost_test = case_when(
  GSP_Rec_both_p == "rec_rate" ~ 3.00,
  GSP_Rec_both_p == "both" ~ 3.00,
  
  GSP_Rec_both_n == "rec_rate" ~ 3.00,
  GSP_Rec_both_n == "both" ~ 3.00,
  TRUE ~ 0.00))

## cost fert is based on rainfall class - define the rainfall class

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::mutate(
    variable_costs = case_when(
      Strip_Type == "P Strip" & rainfall_class == "low" ~     194,
      Strip_Type == "P Strip" & rainfall_class == "medium" ~  358,
      Strip_Type == "P Strip" & rainfall_class == "high" ~    540,
      
      Strip_Type == "N Strip" & rainfall_class == "low" ~     220,
      Strip_Type == "N Strip" & rainfall_class == "medium" ~  340,
      Strip_Type == "N Strip" & rainfall_class == "high" ~    498))

### I don't get this step but it converts N applied from kg/ha to cost of N $ha
str(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::mutate(
    Cost_P_N_dollar_ha  = case_when(
      Strip_Type == "P Strip"  ~     Total_sum_P_content * 2.9,
      Strip_Type == "N Strip"  ~     Total_sum_N_content * 1.1))     

## GM
#GM = Income grain – cost test – variable cost – cost of N


t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::mutate(
    total_cost = cost_test + variable_costs + Cost_P_N_dollar_ha,
    GM  = grain_income - total_cost)

names(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::select(-diff_p_rec_applied,
                -diff_n_rec_applied,
                -closest_match_p,
                -closest_match_n,
                -grain_income,
                -cost_test,
                -variable_costs,
                -Cost_P_N_dollar_ha,
                -total_cost  )

#write.csv(t.test_details_rec_rates_20, "W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/GM_t.test_details_rec_rates2020.csv")


##########################################################################################################
##### scrap_notes4_2020_yld_resposne_economics.R
##########################################################################################################

#########################################################################################################################################################
### 1. bring in the data
#t.test_details_rec_rates_20 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/t.test_details_rec_rates_2020.csv")
# t.test_details_rec_rates_20 <- t.test_details_rec_rates
#########################################################################################################################################################
### 2. remove the alt GSP
### all of this analysis will be without the Alt GSP so I will remove it
#str(t.test_details_rec_rates_20)

#unique(t.test_details_rec_rates_20$GSP)
t.test_details_rec_rates_20$GSP <- as.character(t.test_details_rec_rates_20$GSP)


#unique(t.test_details_rec_rates_20$GSP)
### difference between p rec and p applied

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(diff_p_rec_applied = abs(Total_sum_P_content- p_rec))
closest_match_p <-t.test_details_rec_rates_20 %>%
  group_by(Zone_ID) %>% 
  summarise(closest_match_p = min(diff_p_rec_applied))


#Add this back in

t.test_details_rec_rates_20 <- left_join(t.test_details_rec_rates_20, closest_match_p)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(rec_rate_approx_p =
           case_when(
             closest_match_p == diff_p_rec_applied ~ "approx_rec_rate"))

unique(t.test_details_rec_rates_20$GSP)
t.test_details_rec_rates_20$GSP <- as.character(t.test_details_rec_rates_20$GSP)

str(t.test_details_rec_rates_20$GSP)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(GSP_Rec_both_p = case_when(
    GSP == "GSP"  & rec_rate_approx_p == "approx_rec_rate" ~ "both",
    is.na(GSP)            & rec_rate_approx_p == "approx_rec_rate" ~ "rec_rate",
    GSP == "GSP"  & is.na(rec_rate_approx_p) ~ "GSP",
    TRUE ~ "other"
  ))


### difference between N rec and N applied
names(t.test_details_rec_rates_20)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(diff_n_rec_applied = abs(Total_sum_N_content- Rec_N_jax))

closest_match_n <-t.test_details_rec_rates_20 %>%
  group_by(Zone_ID) %>% 
  summarise(closest_match_n = min(diff_n_rec_applied))


#Add this back in


t.test_details_rec_rates_20 <- left_join(t.test_details_rec_rates_20, closest_match_n)
str(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(rec_rate_approx_n =
           case_when(
             closest_match_n == diff_n_rec_applied ~ "approx_rec_rate"))



t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(GSP_Rec_both_n = case_when(
    GSP == "GSP"  & rec_rate_approx_n == "approx_rec_rate" ~ "both",
    is.na(GSP)            & rec_rate_approx_n == "approx_rec_rate" ~ "rec_rate",
    GSP == "GSP"  & is.na(rec_rate_approx_n) ~ "GSP",
    TRUE ~ "other"
  ))








#### arrange the data so that I have the order of detail that reflects it.
names(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::select(
    
    #Tier 1
    Paddock_ID,
    Strip_Type,
    Organisation,
    Contact,
    Farmer,
    Paddock_tested,
    rainfall_class,
    AGROECOLOG,
    
    #Tier 2
    Zone_ID,
    Total_N,
    Colwell,
    DGT,
    PBI,
    p_rec,
    maxN,
    Rec_N_jax,
    #p_rec_jax,
    
    #Tier 3
    Rate,
    GSP,
    Total_sum_N_content,
    Total_sum_P_content,
    Yld,
    P_value,
    Mean_diff,
    rounded,
    Significant,
    
    #Tier 3 details# 
    diff_p_rec_applied,
    closest_match_p,
    rec_rate_approx_p,
    GSP_Rec_both_p,
    diff_n_rec_applied,
    closest_match_n,
    rec_rate_approx_n,
    GSP_Rec_both_n
  )    



##############################################################################
### add some GM to yld results 
##############################################################################
# convert the yield to income of grain $/ha
# this assumes that all yield is in t /ha 
# all crops are wheat
# the 5 year wheat average is $286 and is same for all sites.
names(df)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% mutate(grain_income = Yld * 286)

##############################################################################
## cost for test $3 per ha for rates the approx rate here some GSP are also approx rec rate labelled as both

names(t.test_details_rec_rates_20)
unique(t.test_details_rec_rates_20$GSP_Rec_both_p)
unique(t.test_details_rec_rates_20$GSP_Rec_both_n)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% mutate(cost_test = case_when(
  GSP_Rec_both_p == "rec_rate" ~ 3.00,
  GSP_Rec_both_p == "both" ~ 3.00,
  
  GSP_Rec_both_n == "rec_rate" ~ 3.00,
  GSP_Rec_both_n == "both" ~ 3.00,
  TRUE ~ 0.00))

## cost fert is based on rainfall class - define the rainfall class

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::mutate(
    variable_costs = case_when(
      Strip_Type == "P Strip" & rainfall_class == "low" ~     194,
      Strip_Type == "P Strip" & rainfall_class == "medium" ~  358,
      Strip_Type == "P Strip" & rainfall_class == "high" ~    540,
      
      Strip_Type == "N Strip" & rainfall_class == "low" ~     220,
      Strip_Type == "N Strip" & rainfall_class == "medium" ~  340,
      Strip_Type == "N Strip" & rainfall_class == "high" ~    498))

### I don't get this step but it converts N applied from kg/ha to cost of N $ha
str(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::mutate(
    Cost_P_N_dollar_ha  = case_when(
      Strip_Type == "P Strip"  ~     Total_sum_P_content * 2.9,
      Strip_Type == "N Strip"  ~     Total_sum_N_content * 1.1))     

## GM
#GM = Income grain – cost test – variable cost – cost of N


t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::mutate(
    total_cost = cost_test + variable_costs + Cost_P_N_dollar_ha,
    GM  = grain_income - total_cost)

names(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::select(-diff_p_rec_applied,
                -diff_n_rec_applied,
                -closest_match_p,
                -closest_match_n,
                -grain_income,
                -cost_test,
                -variable_costs,
                -Cost_P_N_dollar_ha,
                -total_cost  )

#write.csv(t.test_details_rec_rates_20, #"W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/GM_t.test_details_rec_rates2020.csv")

All_zone_rates_2020 <- t.test_details_rec_rates_20

```


```{r stuff around getting  2019 data, message=TRUE, warning=FALSE, include=FALSE}

#Get this from the scrap notes 4 should be 2 files.
# I will add the code in here but for now I will just use this file

### scrap_notes4_2016


## getting the yield difference and GM difference between GSP and Approx
all_strips2019 <- st_read("W:/value_soil_testing_prj/Yield_data/finished/GIS_Results/All_Strips_2019_wgs84.shp")
all_strips2019 <- all_strips2019 %>%
  dplyr::select(Paddock_ID, geometry) 

#2.turn polygons into points - centriod
all_strips2019_centroid = st_centroid(all_strips2019)
all_strips2019_centroid <- all_strips2019_centroid %>%  filter(!is.na(Paddock_ID))
#3.
av_rain <- raster::raster("W:/value_soil_testing_prj/Yield_data/2020/processing/rain_grid")

##3a. extract strips coordinates points from the raster (eg shapefile points and average rainfall grid)
all_strips2019_centroid$av_rain <- raster::extract(av_rain, all_strips2019_centroid)
all_strips2019_centroid_df <- as.data.frame(all_strips2019_centroid ) %>%  dplyr::select(-geometry)
rm(all_strips2019, all_strips2019_centroid, av_rain)


## add in GRDC zone
zone2019_GRDC_bound <- st_read("W:/value_soil_testing_prj/Yield_data/finished/GIS_Results/All_Zones_2019_GRDC_wgs84.shp")

zone2019_GRDC_bound <- zone2019_GRDC_bound %>% 
  dplyr::select(Zone_ID,
                AGROECOLOG)
zone2019_GRDC_bound <- as.data.frame(zone2019_GRDC_bound) %>% 
  dplyr::select(- geometry)
##make a paddock_ID clm
zone2019_GRDC_bound$length_zoneID <- nchar(zone2019_GRDC_bound$Zone_ID)
zone2019_GRDC_bound <- zone2019_GRDC_bound %>% 
  mutate(Paddock_ID =   
           case_when(length_zoneID == 6 ~ substr(Zone_ID, start = 1, stop = 5),
                     length_zoneID == 7 ~ substr(Zone_ID, start = 1, stop = 6)))
zone2019_GRDC_bound$Paddock_ID <- as.double(zone2019_GRDC_bound$Paddock_ID)

# str(zone2019_GRDC_bound)
# str(all_strips2019_centroid_df)

all_strips2019_centroid_df <- left_join(all_strips2019_centroid_df, zone2019_GRDC_bound)
all_strips2019_centroid_df <- all_strips2019_centroid_df %>% 
  dplyr::mutate(
    rainfall_class = case_when(
      av_rain<=350 ~ "low",
      av_rain >500 ~ "high",
      TRUE ~ "medium"))


all_strips2019_centroid_df <- all_strips2019_centroid_df %>% 
  dplyr::select( Paddock_ID, 
                AGROECOLOG, 
                rainfall_class) 
                
### oops I need the rates from the fert df

fertiliser_applied2019 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/step2_fert_app_all_step_2019.csv")
#str(fertiliser_applied2019)

fert_2019 <- fertiliser_applied2019 %>% 
  dplyr::select(Paddock_ID, Rate,GSP,Strip_Type,
                Total_sum_N_content,
                Total_sum_P_content) 

rm(fertiliser_applied2019, zone2019_GRDC_bound)
# str(all_strips2019_centroid_df)
# str(fert_2019)
## add it to the other data

details_2019 <- left_join(fert_2019, all_strips2019_centroid_df)
rm(fert_2019,all_strips2019_centroid_df )

# names(details_2019)

## The GSP is coded a bit strange its either a GPS or number - should all be GSP
details_2019 <- details_2019 %>% 
  dplyr::mutate(GSP = case_when(
    GSP =!is.na(GSP) ~ "GSP" 
  ))
#str(details_2019)
## remove a couple of problem strips
details_2019 <- details_2019 %>% 
  filter(Paddock_ID != 31712  |  !is.na(Rate))
details_2019 <- details_2019 %>% 
  filter(Paddock_ID != 51521  |  !is.na(Rate))
details_2019 <- details_2019 %>% 
  filter(Paddock_ID != 51522  |  !is.na(Rate))

#######################################################################################

## bring in the t.test data results

set1_2019 <- read.csv("W:/value_soil_testing_prj/Yield_data/finished/complied/use/Landmark_with_soil2020-06-24_For_TM.csv")
set2_2019 <- read.csv("W:/value_soil_testing_prj/Yield_data/finished/complied/use/Non_landmark_results_soil_and_pair_rates2020-06-25_For_TM.csv")
# str(set1_2019)
# names(set1_2019)
set1_2019 <- set1_2019 %>% 
  dplyr::select(Zone_ID = Paddock.code,
                Organisation,
                Contact,
                Farmer,
                Paddock_tested,
                Rates,
                Yld,
                P_value,Mean_diff,rounded,Significant)

# str(set2_2019)
# names(set2_2019)

set2_2019 <- set2_2019 %>% 
  dplyr::select(Zone_ID = Paddock.code,
                Organisation,
                Contact,
                Farmer,
                Paddock_tested,
                Rates,
                Yld,
                P_value,Mean_diff,rounded,Significant)
# Pole has rates in shapefile that are different to this, its that same but expressed in different units

set2_2019 <- set2_2019 %>%
  dplyr::mutate(Rates = case_when(
    Paddock_tested == 	"Georges" & Rates ==  0 ~ 0,
    Paddock_tested == 	"Georges" & Rates ==  3 ~ 23,
    Paddock_tested == 	"Georges" & Rates ==  6 ~ 46,
    Paddock_tested == 	"Georges" & Rates ==  9 ~ 69,
    Paddock_tested == 	"Georges" & Rates ==  12 ~ 92,
    Paddock_tested == 	"Georges" & Rates ==  15 ~ 115,
    TRUE ~ as.double(Rates)
  ))

t.test_2019 <- rbind(set2_2019, set1_2019)
rm(set1_2019, set2_2019)

##make a paddock_ID clm
t.test_2019$length_zoneID <- nchar(t.test_2019$Zone_ID)
t.test_2019 <- t.test_2019 %>% 
  mutate(Paddock_ID =   
           case_when(length_zoneID == 6 ~ substr(Zone_ID, start = 1, stop = 5),
                     length_zoneID == 7 ~ substr(Zone_ID, start = 1, stop = 6)))
t.test_2019$Paddock_ID <- as.double(t.test_2019$Paddock_ID)



## The t test data does not have N or P Strips and there is duplication
#str(t.test_2019)
t.test_2019 <- t.test_2019 %>% 
  dplyr::mutate(Strip_Type = case_when(
    Paddock_ID == 31132 ~ "N Strip",
    Paddock_ID == 31231 ~ "N Strip",
    Paddock_ID == 31233 ~ "N Strip",
    Paddock_ID == 31711 ~ "N Strip",
    Paddock_ID == 31712 ~ "N Strip",
    Paddock_ID == 31726 ~ "N Strip",
    Paddock_ID == 51512 ~ "N Strip",
    Paddock_ID == 51713 ~ "N Strip",
    Paddock_ID == 51911 ~ "N Strip",
    Paddock_ID == 51914 ~ "N Strip",
    Paddock_ID == 51915 ~ "N Strip",
    Paddock_ID == 52413 ~ "N Strip",
    Paddock_ID == 52444 ~ "N Strip",
    Paddock_ID == 52453 ~ "N Strip",
    Paddock_ID == 51511 ~ "N Strip",
    Paddock_ID == 33311 ~ "N and P Strip",
    Paddock_ID == 33321 ~ "N and P Strip",
    Paddock_ID == 33331 ~ "N and P Strip",
    TRUE ~ "P Strip"
  ))
## Ann paddocks are a bit of a mess some results are for P and some are for N I have used TB analysis to work out which is which
t.test_2019 <- t.test_2019 %>% 
  dplyr::mutate(Strip_Type = case_when(
    #Schlitz_M2
    Zone_ID == 333110 & Rates == 0 & Yld < 3 ~ "N Strip",
    Zone_ID == 333110 & Rates == 60  ~ "N Strip",
    Zone_ID == 333110 & Rates == 120  ~ "N Strip",
    
    Zone_ID == 333110 & Rates == 0 & Yld > 3 ~ "P Strip",
    Zone_ID == 333110 & Rates == 20  ~ "P Strip",
    Zone_ID == 333110 & Rates == 40  ~ "P Strip",
    Zone_ID == 333110 & Rates == 80  ~ "P Strip",
    
    
    #Schlitz_M2
    Zone_ID == 333111 & Rates == 0 & Yld > 2.69 ~ "N Strip",
    Zone_ID == 333111 & Rates == 60  ~ "N Strip",
    Zone_ID == 333111 & Rates == 120  ~ "N Strip",
    
    Zone_ID == 333111 & Rates == 0 & Yld < 2.69 ~ "P Strip",
    Zone_ID == 333111 & Rates == 20  ~ "P Strip",
    Zone_ID == 333111 & Rates == 40  ~ "P Strip",
    Zone_ID == 333111 & Rates == 80  ~ "P Strip",
    
    #Chamberlain_2
    Zone_ID == 333211 & Rates == 25  ~ "P Strip",
    Zone_ID == 333211 & Rates == 50  ~ "P Strip",
    Zone_ID == 333211 & Rates == 75  ~ "P Strip",
    
    Zone_ID == 333210 & Rates == 25  ~ "P Strip",
    Zone_ID == 333210 & Rates == 50  ~ "P Strip",
    Zone_ID == 333210 & Rates == 75  ~ "P Strip",
    
    Zone_ID == 333211 & Rates == 0  ~ "N Strip",
    Zone_ID == 333211 & Rates == 60  ~ "N Strip",
    Zone_ID == 333211 & Rates == 120  ~ "N Strip",
    
    Zone_ID == 333210 & Rates == 0  ~ "N Strip",
    Zone_ID == 333210 & Rates == 60  ~ "N Strip",
    Zone_ID == 333210 & Rates == 120  ~ "N Strip",
    
    
    #Nelson_3
    Zone_ID == 333311 & Rates == 0 & Yld < 1.5 ~ "P Strip",
    Zone_ID == 333311 & Rates == 25 & Yld > 1.5 ~ "P Strip",
    Zone_ID == 333311 & Rates == 50 & Yld < 1.5 ~ "P Strip",
    Zone_ID == 333311 & Rates == 75  ~ "P Strip",
    
    Zone_ID == 333310 & Rates == 0 & Yld > 1.8 ~ "P Strip",
    Zone_ID == 333310 & Rates == 25 & Yld < 1.7 ~ "P Strip",
    Zone_ID == 333310 & Rates == 50 & Yld > 1.7 ~ "P Strip",
    Zone_ID == 333310 & Rates == 75  ~ "P Strip",
    
    Zone_ID == 333311 & Rates == 0 & Yld < 1.5 ~ "N Strip",
    Zone_ID == 333311 & Rates == 25 & Yld > 1.5 ~ "N Strip",
    Zone_ID == 333311 & Rates == 50 & Yld < 1.5 ~ "N Strip",
    
    
    Zone_ID == 333311 & Rates == 0 & Yld > 1.5 ~ "N Strip",
    Zone_ID == 333311 & Rates == 25 & Yld < 1.5 ~ "N Strip",
    Zone_ID == 333311 & Rates == 50 & Yld > 1.5 ~ "N Strip",
    
    Zone_ID == 333310 & Rates == 0 & Yld < 1.8 ~ "N Strip",
    Zone_ID == 333310 & Rates == 25 & Yld > 1.7 ~ "N Strip",
    Zone_ID == 333310 & Rates == 50 & Yld < 1.7 ~ "N Strip",
    
    TRUE ~ Strip_Type
  ))

# is  paddock is missing code "Landmark	James_Falvey_2	Tim_McClelland_4	Mervyns" but I am not sure it should be included??
# names(t.test_2019)
t.test_2019 <- t.test_2019 %>% 
  dplyr::mutate(Zone_ID = case_when(
    Paddock_tested == "Mervyns" ~ 312431,
    TRUE ~ as.double(Zone_ID)
  ) )




## I want to join details_2019 to t.test 

# str(t.test_2019)
# str(details_2019)

t.test_2019 <- t.test_2019 %>% 
  dplyr::mutate(for_join = paste0(Paddock_ID, Strip_Type, Rates))
details_2019 <- details_2019 %>% 
  dplyr::mutate(for_join = paste0(Paddock_ID, Strip_Type, Rate))

t.test2019_details <- full_join(details_2019, t.test_2019)
# names(t.test2019_details)

# I have two problem paddocks Jeff (53621) no rates no analysis and Mervyns non zone 312431 

t.test2019_details <- t.test2019_details %>% 
  filter(Paddock_tested != "Mervyns")
t.test2019_details <- t.test2019_details %>% 
  filter(Paddock_ID != 53621)

t.test2019_details <- t.test2019_details %>%
  dplyr::select(Zone_ID,
                Paddock_ID,
                Strip_Type,
                Rate,
                GSP,
                Strip_Type,
                Total_sum_N_content,
                Total_sum_P_content,
                Yld,
                Organisation,
                Contact,
                Farmer,
                Paddock_tested,
                rainfall_class,
                AGROECOLOG,
                P_value,
                Mean_diff,
                rounded,
                Significant)
#### This is ready for more the recomm rates



####################################################################################################################################################
## bring in rec rates ##

recom_rateDB2019 <- read_excel( "W:/value_soil_testing_prj/data_base/downloaded_sep2021/GRDC 2019 Paddock Database_SA_VIC_June11 2021.xlsx")
# str(recom_rateDB2019)
# select only a few clms with recommedation 
recom_rateDB2019 <- recom_rateDB2019 %>% 
  dplyr::select(Zone_ID =    `Paddock code` ,
                Total_N = `Total N`, 
                p_rec =           `P rec`,
                n_rec_yld_low =   `N Rec (< 3 t/ha)` ,       
                n_rec_yld_med =   `N Rec (3-5 t/ha)` ,             
                n_rec_yld_high =  `N Rec (> 5 t/ha)`,
                Colwell,
                DGT,
                PBI
                
  ) 

recom_rateDB2019$n_rec_yld_low <- as.double(recom_rateDB2019$n_rec_yld_low)
recom_rateDB2019$n_rec_yld_med <- as.double(recom_rateDB2019$n_rec_yld_med)
recom_rateDB2019$n_rec_yld_high <- as.double(recom_rateDB2019$n_rec_yld_high)
recom_rateDB2019$Colwell <- as.double(recom_rateDB2019$Colwell)
recom_rateDB2019$DGT <- as.double(recom_rateDB2019$DGT)
recom_rateDB2019$PBI <- as.double(recom_rateDB2019$PBI)

recom_rateDB2019 <-  dplyr::mutate(recom_rateDB2019,  maxN = apply(recom_rateDB2019[4:6], 1, max, na.rm = TRUE))


# remove redunant clm and replace inf
recom_rateDB2019 <- recom_rateDB2019 %>% 
  mutate(
    maxN = case_when(
      maxN >= 0 ~ maxN,
      TRUE ~ NA_real_
    )
  )

recom_rateDB2019 <- recom_rateDB2019 %>% 
  dplyr::select(Zone_ID  ,
                p_rec ,
                maxN,
                Total_N,
                Colwell,
                DGT,
                PBI)

##make a paddock_ID clm
recom_rateDB2019$length_zoneID <- nchar(recom_rateDB2019$Zone_ID)
recom_rateDB2019 <- recom_rateDB2019 %>% 
  mutate(Paddock_ID =   
           case_when(length_zoneID == 6 ~ substr(Zone_ID, start = 1, stop = 5),
                     length_zoneID == 7 ~ substr(Zone_ID, start = 1, stop = 6)))
recom_rateDB2019$Paddock_ID <- as.double(recom_rateDB2019$Paddock_ID)

# str(recom_rateDB2019) #this has all the zones
# str(fert_2019_rain_GSP) #this has the paddock details

rm(details_2019, t.test_2019)

### join the t.test data to the recom rates
# str(recom_rateDB2019)
# str(t.test2019_details)

t.test_details_rec_rates <- left_join(t.test2019_details, recom_rateDB2019)
rm(recom_rateDB2019, t.test2019_details)
#############################################################################################################
### Redo the rec rates for N with my rainfall zone

t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(Rec_N_jax = case_when(
    rainfall_class == "low" & Total_N <= 80 ~ ((80 -Total_N)/0.5),
    rainfall_class == "medium" & Total_N <= 160 ~ ((160 -Total_N)/0.5),
    rainfall_class == "high" & Total_N <= 240 ~ ((240 -Total_N)/0.5),
    TRUE                           ~ 0  ))

# str(t.test_details_rec_rates)

# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(critical_colwell = 4.6*( PBI^ (0.393)))
# ## is colwell greater than critical colwell?
# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(colwell_thershold = case_when(
#     Colwell > critical_colwell ~ "adequate",
#     Colwell < critical_colwell ~ "p_required")  )

## if p is required how much extra colwell p is needed to get to critical thershold?
# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(to_reach_col_thershold = case_when(
#     colwell_thershold == "p_required" ~ critical_colwell - Colwell))
# 
# ## what is the recomm P rate?
# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(p_rec_jax = case_when(
#     colwell_thershold == "p_required" ~ ((0.0019*PBI+2.146)*to_reach_col_thershold),
#     colwell_thershold == "adequate" ~ 5
#     ))
# ## clean up extra clms
# 
# names(t.test_details_rec_rates)
# 
# t.test_details_rec_rates <- t.test_details_rec_rates %>%
#   dplyr::select(-"length_zoneID",
#                 - critical_colwell,
#                 - colwell_thershold,
#                 - to_reach_col_thershold)


###################################################################################################################################
#write this out 
# write.csv(t.test_details_rec_rates, "W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/t.test_details_rec_rates_2019.csv")



###################################################################################################################################   Scrap_notes4_2019_yld_response_economics.R


# t.test_details_rec_rates <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/t.test_details_rec_rates_2019.csv")
# 
# str(t.test_details_rec_rates)


### difference between p rec and p applied

t.test_details_rec_rates$p_rec <- as.double(t.test_details_rec_rates$p_rec)

t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(diff_p_rec_applied = abs(Total_sum_P_content- p_rec))
closest_match_p <-t.test_details_rec_rates %>%
  group_by(Zone_ID) %>% 
  summarise(closest_match_p = min(diff_p_rec_applied))


#Add this back in

t.test_details_rec_rates <- left_join(t.test_details_rec_rates, closest_match_p)
t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(rec_rate_approx_p =
           case_when(
             closest_match_p == diff_p_rec_applied ~ "approx_rec_rate"))

unique(t.test_details_rec_rates$GSP)
t.test_details_rec_rates$GSP <- as.character(t.test_details_rec_rates$GSP)

# str(t.test_details_rec_rates$GSP)

t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(GSP_Rec_both_p = case_when(
    GSP == "GSP"  & rec_rate_approx_p == "approx_rec_rate" ~ "both",
    is.na(GSP)            & rec_rate_approx_p == "approx_rec_rate" ~ "rec_rate",
    GSP == "GSP"  & is.na(rec_rate_approx_p) ~ "GSP",
    TRUE ~ "other"
  ))


### difference between N rec and N applied
# names(t.test_details_rec_rates)

t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(diff_n_rec_applied = abs(Total_sum_N_content- Rec_N_jax))

closest_match_n <-t.test_details_rec_rates %>%
  group_by(Zone_ID) %>% 
  summarise(closest_match_n = min(diff_n_rec_applied))


#Add this back in


t.test_details_rec_rates <- left_join(t.test_details_rec_rates, closest_match_n)
# str(t.test_details_rec_rates)
t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(rec_rate_approx_n =
           case_when(
             closest_match_n == diff_n_rec_applied ~ "approx_rec_rate"))



t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(GSP_Rec_both_n = case_when(
    GSP == "GSP"  & rec_rate_approx_n == "approx_rec_rate" ~ "both",
    is.na(GSP)            & rec_rate_approx_n == "approx_rec_rate" ~ "rec_rate",
    GSP == "GSP"  & is.na(rec_rate_approx_n) ~ "GSP",
    TRUE ~ "other"
  ))








#### arrange the data so that I have the order of detail that reflects it.
# names(t.test_details_rec_rates)
t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  dplyr::select(

#Tier 1
Paddock_ID,
Strip_Type,
Organisation,
Contact,
Farmer,
Paddock_tested,
rainfall_class,
AGROECOLOG,

#Tier 2
Zone_ID,
Total_N,
Colwell,
DGT,
PBI,
p_rec,
maxN,
Rec_N_jax,
#p_rec_jax,
 
#Tier 3
Rate,
GSP,
Total_sum_N_content,
Total_sum_P_content,
Yld,
P_value,
Mean_diff,
rounded,
Significant,

#Tier 3 details# 
diff_p_rec_applied,
closest_match_p,
rec_rate_approx_p,
GSP_Rec_both_p,
diff_n_rec_applied,
closest_match_n,
rec_rate_approx_n,
GSP_Rec_both_n
)    



##############################################################################
### add some GM to yld results 
##############################################################################
# convert the yield to income of grain $/ha
# this assumes that all yield is in t /ha 
# all crops are wheat
# the 5 year wheat average is $286 and is same for all sites.

t.test_details_rec_rates <- t.test_details_rec_rates %>% mutate(grain_income = Yld * 286)

##############################################################################
## cost for test $3 per ha for rates the approx rate here some GSP are also approx rec rate labelled as both

# names(t.test_details_rec_rates)
# unique(t.test_details_rec_rates$GSP_Rec_both_p)
# unique(t.test_details_rec_rates$GSP_Rec_both_n)

t.test_details_rec_rates <- t.test_details_rec_rates %>% mutate(cost_test = case_when(
  GSP_Rec_both_p == "rec_rate" ~ 3.00,
  GSP_Rec_both_p == "both" ~ 3.00,
  
  GSP_Rec_both_n == "rec_rate" ~ 3.00,
  GSP_Rec_both_n == "both" ~ 3.00,
  TRUE ~ 0.00))

## cost fert is based on rainfall class - define the rainfall class

t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  dplyr::mutate(
    variable_costs = case_when(
      Strip_Type == "P Strip" & rainfall_class == "low" ~     194,
      Strip_Type == "P Strip" & rainfall_class == "medium" ~  358,
      Strip_Type == "P Strip" & rainfall_class == "high" ~    540,
      
      Strip_Type == "N Strip" & rainfall_class == "low" ~     220,
      Strip_Type == "N Strip" & rainfall_class == "medium" ~  340,
      Strip_Type == "N Strip" & rainfall_class == "high" ~    498))

### I don't get this step but it converts N applied from kg/ha to cost of N $ha
# str(t.test_details_rec_rates)
t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  dplyr::mutate(
    Cost_P_N_dollar_ha  = case_when(
      Strip_Type == "P Strip"  ~     Total_sum_P_content * 2.9,
      Strip_Type == "N Strip"  ~     Total_sum_N_content * 1.1))     

## GM
#GM = Income grain – cost test – variable cost – cost of N


t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  dplyr::mutate(
    total_cost = cost_test + variable_costs + Cost_P_N_dollar_ha,
    GM  = grain_income - total_cost)

# names(t.test_details_rec_rates)
all_step_t.test_details_rec_rates <- t.test_details_rec_rates
neat_t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  dplyr::select(-diff_p_rec_applied,
                -diff_n_rec_applied,
                -closest_match_p,
                -closest_match_n,
                -grain_income,
                -cost_test,
                -variable_costs,
                -Cost_P_N_dollar_ha,
                -total_cost  )

# write.csv(neat_t.test_details_rec_rates, "W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/GM_t.test_details_rec_rates2019.csv")



All_zone_rates_2019 <-neat_t.test_details_rec_rates


# All_zone_rates_2019 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/GM_t.test_details_rec_rates2019.csv")


```


### How many strips?
```{r how many strips 2019 and 2020, echo=FALSE, message=TRUE, warning=FALSE}

#How many strips?

#####2019
count_strip_2019 <- All_zone_rates_2019 %>% 
  dplyr::select(Paddock_ID , Strip_Type,
                rainfall_class,
                Zone_ID,
                Rate,
                GSP)

count_strip_2019$rainfall_class <- factor(count_strip_2019$rainfall_class, 
                                                            levels = c("low", "medium", "high"))

#unique(count_strip_2019$GSP) #check that I have no alter strip

### N
count_strip_N_2019 <-count_strip_2019 %>% 
  filter(Strip_Type == "N Strip") %>% 
  distinct(Zone_ID, Rate, .keep_all = TRUE)

count_strip_N_2019 %>%  group_by(rainfall_class) %>% 
  summarise(numb_N_strips = n())
count_strip_N_2019 %>%  
  summarise(numb_N_strips = n())

### P
count_strip_P_2019 <-count_strip_2019 %>% 
  filter(Strip_Type == "P Strip") %>% 
  distinct(Zone_ID, Rate, .keep_all = TRUE)

count_strip_P_2019 %>%  group_by(rainfall_class) %>% 
  summarise(numb_P_strips = n())
count_strip_P_2019 %>%  
  summarise(numb_P_strips = n())


#####2020
count_strip_2020 <- All_zone_rates_2020 %>% 
  dplyr::select(Paddock_ID , Strip_Type,
                rainfall_class,
                Zone_ID,
                Rate,
                GSP)

count_strip_2020$rainfall_class <- factor(count_strip_2020$rainfall_class, 
                                                            levels = c("low", "medium", "high"))
#unique(count_strip_2020$GSP) #check that I have no alter strip

### N
count_strip_N_2020 <-count_strip_2020 %>% 
  filter(Strip_Type == "N Strip") %>% 
  distinct(Zone_ID, Rate, .keep_all = TRUE)

count_strip_N_2020 %>%  group_by(rainfall_class) %>% 
  summarise(numb_N_strips = n())
count_strip_N_2020 %>%  
  summarise(numb_N_strips = n())

### P
count_strip_P_2020 <-count_strip_2020 %>% 
  filter(Strip_Type == "P Strip") %>% 
  distinct(Zone_ID, Rate, .keep_all = TRUE)

count_strip_P_2020 %>%  group_by(rainfall_class) %>% 
  summarise(numb_P_strips = n())
count_strip_P_2020 %>%  
  summarise(numb_P_strips = n())
  
```




# So did soil testing lead to higher recommended N and P rates?


### Plots for 2019

```{r soil testing recom plot 2019 prep, message=TRUE, warning=FALSE, include=FALSE}

## Duplication may have crept in ?? I only want one zoneID strip type and rate
GM_t.test_details_rec_rates2019 <- All_zone_rates_2019 %>% 
  distinct(Zone_ID, Strip_Type,Rate, .keep_all = TRUE)
### the GM has some negative values lets recode these as zero
#str(GM_t.test_details_rec_rates2019) #349

#min(GM_t.test_details_rec_rates2019$GM, na.rm = TRUE)
GM_t.test_details_rec_rates2019  <- GM_t.test_details_rec_rates2019 %>% 
  mutate(GM = case_when(
    GM < 0 ~ 0,
    TRUE ~ GM
  ))


############################################################################

GM_t.test_details_rec_rates2019_P <- GM_t.test_details_rec_rates2019 %>% 
  dplyr::filter(Strip_Type == "P Strip")
#str(GM_t.test_details_rec_rates2019_P)

P_zone_2019 <- GM_t.test_details_rec_rates2019_P %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:Rec_N_jax)

plot_rec_P_2019 <-ggplot(P_zone_2019, aes(x=p_rec)) +
  geom_histogram(aes(y = stat(count) / sum(count))) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1))+
  #facet_wrap(.~ rainfall_class_f)+
  theme_bw() +
  geom_vline(
    xintercept = 5,
    linetype = "dotted",
    color = "red",
    size = 2.0
  ) +
  #scale_x_continuous(breaks = seq(-5.0, 5.0, by = .5))+
  labs(
    title = "Recommendation for P 2019",
    y = "Frequency of zones",
    x = "Fertiliser recommendation (kg P/ha)"#,
   # subtitle = "only including zones used in economic analysis (n =103)"
  )+
  theme(axis.title.y = element_text(size = 12),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10))



###########################   N    ###########################################
GM_t.test_details_rec_rates2019_N <- GM_t.test_details_rec_rates2019 %>% 
  dplyr::filter(Strip_Type == "N Strip")

N_zone <- GM_t.test_details_rec_rates2019_N %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:Rec_N_jax)


plot_rec_N_2019 <-ggplot(N_zone, aes(x=Rec_N_jax)) +
  geom_histogram(aes(y = stat(count) / sum(count))) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0, 0.6))+
  #facet_wrap(.~ rainfall_class_f)+
  theme_bw() +
  geom_vline(
    xintercept = 0,
    linetype = "dotted",
    color = "red",
    size = 2.0
  ) +
  #scale_x_continuous(breaks = seq(-5.0, 5.0, by = .5))+
  labs(
    title = "Recommendation for N 2019",
    y = "Frequency of zones",
    x = "Fertiliser recommendation (kg N/ha)")+
  #subtitle = "only including zones used in economic analysis (n =70)"
  theme(axis.title.y = element_text(size = 12),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10))

```

```{r soil testing recom plot 2019, echo=FALSE, message=TRUE, warning=FALSE}

grid.arrange(plot_rec_N_2019, plot_rec_P_2019, nrow = 1)


```




```{r soil testing recom plot 2020 prep, message=TRUE, warning=FALSE, include=FALSE}
 
## Duplication may have crept in ?? I only want one zoneID strip type and rate
GM_t.test_details_rec_rates2020 <- All_zone_rates_2020 %>% 
  distinct(Zone_ID, Strip_Type,Rate, .keep_all = TRUE)
### the GM has some negative values lets recode these as zero
#str(GM_t.test_details_rec_rates2019) #349

#min(GM_t.test_details_rec_rates2019$GM, na.rm = TRUE)
GM_t.test_details_rec_rates2020  <- GM_t.test_details_rec_rates2020 %>% 
  mutate(GM = case_when(
    GM < 0 ~ 0,
    TRUE ~ GM
  ))


############################################################################

GM_t.test_details_rec_rates2020_P <- GM_t.test_details_rec_rates2020 %>% 
  dplyr::filter(Strip_Type == "P Strip")
#str(GM_t.test_details_rec_rates2019_P)

P_zone_2020 <- GM_t.test_details_rec_rates2020_P %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:Rec_N_jax)

plot_rec_P_2020 <-ggplot(P_zone_2020, aes(x=p_rec)) +
  geom_histogram(aes(y = stat(count) / sum(count))) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1),limits = c(0, 0.6))+
  #facet_wrap(.~ rainfall_class_f)+
  theme_bw() +
  geom_vline(
    xintercept = 5,
    linetype = "dotted",
    color = "red",
    size = 2.0
  ) +
  #scale_x_continuous(breaks = seq(-5.0, 5.0, by = .5))+
  labs(
    title = "Recommendation for P 2020",
    y = "Frequency of zones",
    x = "Fertiliser Recommendation (kg P/ha)"
    #subtitle = "only including zones used in economic analysis (n =103)"
  )+
  theme(axis.title.y = element_text(size = 12),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10))



###########################   N    ###########################################
GM_t.test_details_rec_rates2020_N <- GM_t.test_details_rec_rates2020 %>% 
  dplyr::filter(Strip_Type == "N Strip")

N_zone <- GM_t.test_details_rec_rates2020_N %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:Rec_N_jax)


plot_rec_N_2020 <-ggplot(N_zone, aes(x=Rec_N_jax)) +
  geom_histogram(aes(y = stat(count) / sum(count))) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1),limits = c(0, 0.6))+
  #facet_wrap(.~ rainfall_class_f)+
  theme_bw() +
  geom_vline(
    xintercept = 0,
    linetype = "dotted",
    color = "red",
    size = 2.0
  ) +
  #scale_x_continuous(breaks = seq(-5.0, 5.0, by = .5))+
  labs(
    title = "Recommendation for N 2020",
    y = "Frequency of zones",
    x = "Fertiliser Recommendation (kg N/ha)")+
  #subtitle = "only including zones used in economic analysis (n =70)"
  theme(axis.title.y = element_text(size = 12),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10))


```

### Plots for 2020

```{r soil testing recom plot 2020, echo=FALSE, message=TRUE, warning=FALSE}

grid.arrange(plot_rec_N_2020, plot_rec_P_2020, nrow = 1)


```







### Tables for soil testing and recom rates

When soil test indicates that a yield respose is likely the threshold of p_rec >= 5.
I am not super happy with this thershold.
After talking to Sean, he says that this is the default minmum he recommeded.
Therese has suggested this therhold, so this is saying that we are always expecting a yield resposne.
Beacuse we are always recommededing applying 5 of P.

The table below details how the rec rate suggested changing planned practice (GSP)

Note that the NA in these table relate to entries which are not the GSP.
I am only comparing the rec rate with the GSP so the other strip rates get a NA value.

When soil test indicates that a yield respose is likely the threshold of p_rec > 0.
I am not super happy with this thershold.

Therese has suggested this therhold.



 
```{r soil testing recom plot 2019  P working, echo=FALSE, message=TRUE, warning=FALSE}
### Duplication may have crept in ?? I only want one zoneID strip type and rate
rec_rate_vs_GSP_2019_P_N <- All_zone_rates_2019 %>% 
  distinct(Zone_ID, Strip_Type, Rate, .keep_all = TRUE)
### the GM has some negative values lets recode these as zero
#str(rec_rate_vs_GSP_2019_P_N) #349

############################################################################
rec_rate_vs_GSP_2019_P_N$GSP <- as.character(rec_rate_vs_GSP_2019_P_N$GSP)
rec_rate_vs_GSP_2019_P_N$Strip_Type <- as.character(rec_rate_vs_GSP_2019_P_N$Strip_Type)
#str(GM_t.test_details_rec_rates2019)

###########################   P    ###########################################
rec_rate_vs_GSP_2019_P <- rec_rate_vs_GSP_2019_P_N %>% 
  dplyr::filter(Strip_Type == "P Strip")


rec_rate_vs_GSP_2019_P <- rec_rate_vs_GSP_2019_P %>% mutate(soil_test_says_P = case_when(
  Strip_Type == "P Strip" & GSP == "GSP"& Total_sum_P_content < p_rec ~  "add_more_P",
  Strip_Type == "P Strip" & GSP == "GSP"& Total_sum_P_content == p_rec ~ "no_change",
  Strip_Type == "P Strip" & GSP == "GSP"& Total_sum_P_content > p_rec ~  "less_P",
))

#View(rec_rate_vs_GSP_2019_P)  ## this has all the rates in it
## what is the rec rate per zone
rec_rate_vs_GSP_2019_P_zone <-rec_rate_vs_GSP_2019_P %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:Rec_N_jax)

rec_rate_vs_GSP_2019_P_zone <- rec_rate_vs_GSP_2019_P_zone %>% 
  mutate(yld_repsonse_likely_to_p = case_when(
    p_rec >= 5 ~ "respose",
    TRUE ~ "no_resposne"
  ))
P_zone_count_2019 <- rec_rate_vs_GSP_2019_P_zone %>%  group_by() %>% 
  summarise(zone_2019_P = n() )

table1_2019_P <- rec_rate_vs_GSP_2019_P_zone %>%  
  group_by(yld_repsonse_likely_to_p) %>% 
  summarise(count_p_over5 = n()) 


table2_2019_P <-rec_rate_vs_GSP_2019_P %>%  filter(Strip_Type == "P Strip") %>%
  distinct(Zone_ID, .keep_all = TRUE) %>%
  group_by(soil_test_says_P) %>%
  summarise(count_vs_GSP = n() )

# P_zone_count_2019
# table1_2019_P
# table2_2019_P


```

### P zone in 2019



```{r Count of P zone in 2019, echo=FALSE, message=TRUE, warning=FALSE}


## make into one table
table1_2019_P <- table1_2019_P %>% 
  rename(detail = yld_repsonse_likely_to_p, 
         count= count_p_over5)
table2_2019_P <- table2_2019_P %>% 
  rename(detail = soil_test_says_P, 
         count= count_vs_GSP)
table1_2_2019_P <- rbind(table1_2019_P, table2_2019_P)
table1_2_2019_P <- table1_2_2019_P %>%  mutate(count_zones = 74,
percent = (count /74)*100)

table1_2_2019_P <- table1_2_2019_P %>% 
  mutate(detail =  case_when(
    detail == "respose" ~ "soil test indicated a yield response",
    detail == "add_more_P" ~ "soil test recommended a increase in P",
    detail == "less_P" ~ "soil test recommended a reduction in P",
    TRUE ~ detail
              ))

table1_2_2019_P


```




```{r soil testing recom plot 2019 N working, message=TRUE, warning=FALSE, include=FALSE}

###########################   N    ###########################################
rec_rate_vs_GSP_2019_N <- rec_rate_vs_GSP_2019_P_N %>% 
  dplyr::filter(Strip_Type == "N Strip")


rec_rate_vs_GSP_2019_N <- rec_rate_vs_GSP_2019_N %>% mutate(soil_test_says_N = case_when(
  Strip_Type == "N Strip" & GSP == "GSP"& Total_sum_P_content < Rec_N_jax ~  "add_more_N",
  Strip_Type == "N Strip" & GSP == "GSP"& Total_sum_P_content == Rec_N_jax ~ "no_change",
  Strip_Type == "N Strip" & GSP == "GSP"& Total_sum_P_content > Rec_N_jax ~  "less_N",
))

#View(rec_rate_vs_GSP_2019_P)  ## this has all the rates in it
## what is the rec rate per zone
rec_rate_vs_GSP_2019_N_zone <-rec_rate_vs_GSP_2019_N %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:Rec_N_jax)

rec_rate_vs_GSP_2019_N_zone <- rec_rate_vs_GSP_2019_N_zone %>% 
  mutate(yld_repsonse_likely_to_n = case_when(
    Rec_N_jax > 0 ~ "respose",
    TRUE ~ "no_resposne"
  ))
N_zone_count_2019 <- rec_rate_vs_GSP_2019_N_zone %>%  group_by() %>% 
  summarise(zone_2019_N = n() )

table1_2019_N <- rec_rate_vs_GSP_2019_N_zone %>%  
  group_by(yld_repsonse_likely_to_n) %>% 
  summarise(count_n_over0 = n()) 


table2_2019_N <-rec_rate_vs_GSP_2019_N %>%  
  distinct(Zone_ID, .keep_all = TRUE) %>%
  group_by(soil_test_says_N) %>%
  summarise(count_vs_GSP = n() )
#View(rec_rate_vs_GSP_2019_N)

# N_zone_count_2019
# table1_2019_N
# table2_2019_N
```

### N zone in 2019



```{r Count of N zone in 2019, echo=FALSE, message=TRUE, warning=FALSE}

#N_zone_count_2019

## make into one table
table1_2019_N <- table1_2019_N %>% 
  rename(detail = yld_repsonse_likely_to_n, 
         count= count_n_over0)

table2_2019_N <- table2_2019_N %>% 
  rename(detail = soil_test_says_N, 
         count= count_vs_GSP)
table1_2_2019_N <- rbind(table1_2019_N, table2_2019_N)


table1_2_2019_N <- table1_2_2019_N %>%  mutate(count_zones = 31,
percent = (count /31)*100)

table1_2_2019_N <- table1_2_2019_N %>% 
  mutate(detail =  case_when(
    detail == "respose" ~ "soil test indicated a yield response",
    detail == "add_more_N" ~ "soil test recommended a increase in N",
    detail == "less_N" ~ "soil test recommended a reduction in N",
    TRUE ~ detail
              ))

table1_2_2019_N


```
```{r soil testing rec rates 2020 working, include=FALSE}



### Duplication may have crept in ?? I only want one zoneID strip type and rate
rec_rate_vs_GSP_2020_P_N <- All_zone_rates_2020 %>% 
  distinct(Zone_ID, Strip_Type, Rate, .keep_all = TRUE)
### the GM has some negative values lets recode these as zero
#str(rec_rate_vs_GSP_2020_P_N) #562

############################################################################
rec_rate_vs_GSP_2020_P_N$GSP <- as.character(rec_rate_vs_GSP_2020_P_N$GSP)
rec_rate_vs_GSP_2020_P_N$Strip_Type <- as.character(rec_rate_vs_GSP_2020_P_N$Strip_Type)
#str(GM_t.test_details_rec_rates2020)

###########################   P    ###########################################
rec_rate_vs_GSP_2020_P <- rec_rate_vs_GSP_2020_P_N %>% 
  dplyr::filter(Strip_Type == "P Strip")


rec_rate_vs_GSP_2020_P <- rec_rate_vs_GSP_2020_P %>% mutate(soil_test_says_P = case_when(
  Strip_Type == "P Strip" & GSP == "GSP"& Total_sum_P_content < p_rec ~  "add_more_P",
  Strip_Type == "P Strip" & GSP == "GSP"& Total_sum_P_content == p_rec ~ "no_change",
  Strip_Type == "P Strip" & GSP == "GSP"& Total_sum_P_content > p_rec ~  "less_P",
))

#View(rec_rate_vs_GSP_2020_P)  ## this has all the rates in it
## what is the rec rate per zone
rec_rate_vs_GSP_2020_P_zone <-rec_rate_vs_GSP_2020_P %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:Rec_N_jax,soil_test_says_P )
#str(rec_rate_vs_GSP_2020_P_zone)


#create a new clm
rec_rate_vs_GSP_2020_P_zone <- rec_rate_vs_GSP_2020_P_zone %>% 
  mutate(yld_repsonse_likely_to_p = case_when(
    p_rec >= 5 ~ "respose",
    TRUE ~ "no_resposne"
  ))
## count the number of P zones
P_zone_count2020 <- rec_rate_vs_GSP_2020_P_zone %>%  group_by() %>% 
  summarise(count = n() )
#P_zone_count
# how many zones indicate a yld resposne by the soil test?

table1_2020_P <- rec_rate_vs_GSP_2020_P_zone %>%  
  group_by(yld_repsonse_likely_to_p) %>% 
  summarise(count_P_over5 = n() )

#str(rec_rate_vs_GSP_2020_P_zone)

table2_2020_P <-rec_rate_vs_GSP_2020_P_zone %>%  
  filter(Strip_Type == "P Strip") %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  group_by(soil_test_says_P) %>% 
  summarise(count_vs_GSP = n()) 

# table1_2020_P
# table2_2020_P
# 
# 
# str(rec_rate_vs_GSP_2020_P_N)


###########################   N    ###########################################
rec_rate_vs_GSP_2020_N <- rec_rate_vs_GSP_2020_P_N %>% 
  dplyr::filter(Strip_Type == "N Strip")


rec_rate_vs_GSP_2020_N <- rec_rate_vs_GSP_2020_N %>% mutate(soil_test_says_N = case_when(
  Strip_Type == "N Strip" & GSP == "GSP"& Total_sum_P_content < Rec_N_jax ~  "add_more_N",
  Strip_Type == "N Strip" & GSP == "GSP"& Total_sum_P_content == Rec_N_jax ~ "no_change",
  Strip_Type == "N Strip" & GSP == "GSP"& Total_sum_P_content > Rec_N_jax ~  "less_N",
))

#View(rec_rate_vs_GSP_2020_P)  ## this has all the rates in it
## what is the rec rate per zone
rec_rate_vs_GSP_2020_N_zone <-rec_rate_vs_GSP_2020_N %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:Rec_N_jax, soil_test_says_N)

rec_rate_vs_GSP_2020_N_zone <- rec_rate_vs_GSP_2020_N_zone %>% 
  mutate(yld_repsonse_likely_to_n = case_when(
    Rec_N_jax > 0 ~ "respose",
    TRUE ~ "no_resposne"
  ))
N_zone_count_2020 <- rec_rate_vs_GSP_2020_N_zone %>%  group_by() %>% 
  summarise(zone_2020_N = n() )

table1_2020_N <- rec_rate_vs_GSP_2020_N_zone %>%  
  group_by(yld_repsonse_likely_to_n) %>% 
  summarise(count_n_over0 = n()) 


table2_2020_N <-rec_rate_vs_GSP_2020_N %>%  
  distinct(Zone_ID, .keep_all = TRUE) %>%
  group_by(soil_test_says_N) %>%
  summarise(count_vs_GSP = n() )
#View(rec_rate_vs_GSP_2020_N)

# N_zone_count_2020
# table1_2020_N
# table2_2020_N


```

### P zone in 2020

```{r Count of P zone in 2020, echo=FALSE, message=TRUE, warning=FALSE}

# P_zone_count2020
# table1_2020_P
## make into one table
table1_2020_P <- table1_2020_P %>% 
  rename(detail = yld_repsonse_likely_to_p, 
         count= count_P_over5)

table2_2020_P <- table2_2020_P %>% 
  rename(detail = soil_test_says_P, 
         count= count_vs_GSP)
table1_2_2020_P <- rbind(table1_2020_P, table2_2020_P)
table1_2_2020_P <- table1_2_2020_P %>%  mutate(count_zones = 106,
                                               percent = (count /106)*100)

table1_2_2020_P <- table1_2_2020_P %>% 
  mutate(detail =  case_when(
    detail == "respose" ~ "soil test indicated a yield response",
    detail == "add_more_P" ~ "soil test recommended a increase in P",
    detail == "less_P" ~ "soil test recommended a reduction in P",
    TRUE ~ detail
  ))

table1_2_2020_P


```

### N zone in 2020

```{r Count of N zone in 2020, echo=FALSE, message=TRUE, warning=FALSE}

#N_zone_count_2020
#table1_2020_N

## make into one table
table1_2020_N <- table1_2020_N %>% 
  rename(detail = yld_repsonse_likely_to_n, 
         count= count_n_over0)

table2_2020_N <- table2_2020_N %>% 
  rename(detail = soil_test_says_N, 
         count= count_vs_GSP)
table1_2_2020_N <- rbind(table1_2020_N, table2_2020_N)
table1_2_2020_N <- table1_2_2020_N %>%  mutate(count_zones = 73,
                                               percent = (count /73)*100)

table1_2_2020_N <- table1_2_2020_N %>% 
  mutate(detail =  case_when(
    detail == "respose" ~ "soil test indicated a yield response",
    detail == "add_more_N" ~ "soil test recommended a increase in N",
    detail == "less_N" ~ "soil test recommended a reduction in N",
    TRUE ~ detail
  ))

table1_2_2020_N


```




# How do the recommended rates compare in the multiple zones in the paddock


**Background** 

For most paddocks more than one zone was sampled, therefore there is a potential for paddocks in zones to have different N or P fertiliser recommedation.

It is important to note that the N recommedation uses the rainfall class to dervive the recommedations.

I have used the low, medium, high rainfall class generated by the location of the trial.

Rather than using the database, which has some odd rainfall classifications.

Note Sean has not used the rainfall classification in the DB to generate his N recommendation.

Sean has used a different rainfall class and his N recommendation (that he has used for analysis and presentations sit outside of the database)

I have redone the N recommendation based on the revised rainfall class.

This revised rainfall class is based on the spatial location of the paddocks.

Using this with BOM average rainfall grid and low med and high class defined by Therese.

I have used the P recommedation that are in the DB.
Sean has confirmed that this is the one to use.



#### P trials in 2019


The number of paddocks with either 1, 2,3 zones
How many paddocks have a N rec rate in zone 1 vs zone 2 that is higher than 5 kg


```{r rec rates different in zone 2019 P , echo=FALSE, message=TRUE, warning=FALSE}

## pull out P strip only, only keep zone data
P_zones_2019 <- All_zone_rates_2019 %>% 
  filter(Strip_Type == "P Strip") %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:maxN, rainfall_class)


# for each paddocks what is the max and min P rec (doesnt matter how many zones)
Zone_In_Paddocks_P_2019 <- P_zones_2019 %>%  group_by(Paddock_ID, rainfall_class) %>% 
  summarise(count_zone = n(),
            max_P_rec = max(p_rec, na.rm = FALSE),
            min_P_rec = min(p_rec, na.rm = FALSE))

#difference between high and low
Zone_In_Paddocks_P_2019 <- Zone_In_Paddocks_P_2019 %>% 
  mutate(diff_P_rec_rate = max_P_rec - min_P_rec)

#is the difference greater than 5 then it gets a value of 1
Zone_In_Paddocks_P_2019 <- Zone_In_Paddocks_P_2019 %>% 
  mutate(count_of_diff = case_when(
    count_zone >1 & diff_P_rec_rate >5 ~ 1,
    TRUE ~ 0))
#count how many paddocks have zones with different rec rate that is greater than 5
Zone_In_Paddocks_P_2019 %>%  group_by(count_zone) %>% 
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE))

Zone_In_Paddocks_P_2019 %>%  
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE),
            count =  n(),
            percent_zone_with_diff_rec_P = (sum_of_when_diff/count) *100)


```



#### N trials in 2019

How many paddocks have a N rec rate in zone 1 vs zone 2 that is higher than 10 kg


```{r rec rates different in zone 2019 N , echo=FALSE, message=TRUE, warning=FALSE}
## pull out N strip only, only keep zone data
N_zones_2019 <- All_zone_rates_2019 %>% 
  filter(Strip_Type == "N Strip") %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:Rec_N_jax )


# for each paddocks what is the max and min N rec (doesnt matter how many zones)
Zone_In_Paddocks_N_2019 <- N_zones_2019 %>%  group_by(Paddock_ID) %>% 
  summarise(count_zone = n(),
            max_N_rec = max(Rec_N_jax , na.rm = FALSE),
            min_N_rec = min(Rec_N_jax , na.rm = FALSE))

Zone_In_Paddocks_N_2019 <- Zone_In_Paddocks_N_2019 %>% 
  mutate(diff_N_rec_rate = max_N_rec - min_N_rec)

#is the difference greater than 10 then it gets a value of 1
Zone_In_Paddocks_N_2019 <- Zone_In_Paddocks_N_2019 %>% 
  mutate(count_of_diff = case_when(
    count_zone >1 & diff_N_rec_rate >10 ~ 1,
    TRUE ~ 0))

#count how many paddocks have zones with different rec rate that is greater than 10
Zone_In_Paddocks_N_2019 %>%  group_by(count_zone) %>% 
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE))

Zone_In_Paddocks_N_2019 %>%  
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE),
            count =  n(),
            percent_zone_with_diff_rec_N = (sum_of_when_diff/count) *100)


```


#### P trials in 2020

The paddocks have either 1, 2,3 zones
How many paddocks have a P rec rate in zone 1 vs zone 2 that is higher than 5 kg

Note that in these example when there is more than 2 zone I am comparing the zones with the maximum difference.
e.g for all the zones in a paddock what is max recommend rate and what is the min recommeded rate.
Then the difference between these two needs to greater than 5 kg.


```{r rec rates different in zone 2020 P , echo=FALSE, message=TRUE, warning=FALSE}
## pull out P strip only, only keep zone data
P_zones_2020 <- All_zone_rates_2020 %>% 
  filter(Strip_Type == "P Strip") %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:maxN)


# for each paddocks what is the max and min P rec (doesnt matter how many zones)
Zone_In_Paddocks_P_2020 <- P_zones_2020 %>%  group_by(Paddock_ID) %>% 
  summarise(count_zone = n(),
            max_P_rec = max(p_rec, na.rm = FALSE),
            min_P_rec = min(p_rec, na.rm = FALSE))

#difference between high and low
Zone_In_Paddocks_P_2020 <- Zone_In_Paddocks_P_2020 %>% 
  mutate(diff_P_rec_rate = max_P_rec - min_P_rec)

#is the difference greater than 5 then it gets a value of 1
Zone_In_Paddocks_P_2020 <- Zone_In_Paddocks_P_2020 %>% 
  mutate(count_of_diff = case_when(
    count_zone >1 & diff_P_rec_rate >5 ~ 1,
    TRUE ~ 0))
#count how many paddocks have zones with different rec rate that is greater than 5
Zone_In_Paddocks_P_2020 %>%  group_by(count_zone) %>% 
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE))

Zone_In_Paddocks_P_2020 %>%  
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE),
            count =  n(),
            percent_zone_with_diff_rec_P = (sum_of_when_diff/count) *100)

```

#### N trials in 2020
The number of paddocks with either 1, 2,3 zones
How many paddocks have a P rec rate in zone 1 vs zone 2 that is higher than 10 kg

 


```{r rec rates different in zone 2020 N, echo=FALSE, message=TRUE, warning=FALSE}
## pull out N strip only, only keep zone data
N_zones_2020 <- All_zone_rates_2020 %>% 
  filter(Strip_Type == "N Strip") %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:Rec_N_jax)


# for each paddocks what is the max and min N rec (doesnt matter how many zones)
Zone_In_Paddocks_N_2020 <- N_zones_2020 %>%  group_by(Paddock_ID) %>% 
  summarise(count_zone = n(),
            max_N_rec = max(Rec_N_jax, na.rm = FALSE),
            min_N_rec = min(Rec_N_jax, na.rm = FALSE))

Zone_In_Paddocks_N_2020 <- Zone_In_Paddocks_N_2020 %>% 
  mutate(diff_N_rec_rate = max_N_rec - min_N_rec)

#is the difference greater than 10 then it gets a value of 1
Zone_In_Paddocks_N_2020 <- Zone_In_Paddocks_N_2020 %>% 
  mutate(count_of_diff = case_when(
    count_zone >1 & diff_N_rec_rate >10 ~ 1,
    TRUE ~ 0))

#count how many paddocks have zones with different rec rate that is greater than 10
Zone_In_Paddocks_N_2020 %>%  group_by(count_zone) %>% 
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE))

Zone_In_Paddocks_N_2020 %>%  
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE),
            count =  n(),
            percent_zone_with_diff_rec_N = (sum_of_when_diff/count) *100)

```









## Details on the soil test, recommend rates and the average GSP

### 2019 P zones  

This data set is not great.
I have patchy records for the fertiliser applied and how much was applied over the season.

Therese has done a lot of work here but some sites just don't seem to add up.
A variety of problems, I have used her work as a cross reference.


I have done the N rec rates again and P rec rates - Sean has confirmed that the P rec rates in the DB are correct



```{r GSP recom rates for zone 2019 P, echo=FALSE, message=TRUE, warning=FALSE}

## pull out P strip only that has GSP, only keep zone data
P_zones_2019_GSP_rec_rate <- All_zone_rates_2019 %>%
  filter(Strip_Type == "P Strip") %>%
  filter(GSP == "GSP") %>%
  dplyr::select(Paddock_ID, 
                Zone_ID, 
                #Total_N,
                Colwell,
                DGT,
                PBI,
                p_rec,
                #Rec_N_jax,
                GSP,
                #Total_sum_N_content,
                Total_sum_P_content,
                rainfall_class 
                ) %>%
  distinct(Zone_ID, .keep_all = TRUE)

P_zones_2019_GSP_rec_rate$rainfall_class <- factor(P_zones_2019_GSP_rec_rate$rainfall_class, 
                                                            levels = c("low", "medium", "high"))


P_zones_2019_GSP_rec_rate %>%  group_by(rainfall_class) %>%
  summarise(Av_P_Colwell = mean(Colwell, na.rm = TRUE),
            Av_P_DGT = mean(DGT, na.rm = TRUE),
           # Av_P_PBI = mean(PBI, na.rm = TRUE),
            Av_P_rec_rate = mean(p_rec, na.rm = TRUE),
            Av_P_GSP = mean(Total_sum_P_content, na.rm = TRUE),
            count = n()
            
  )

```

### 2019 N zones 

Again note that the dataset is not great.


```{r r GSP recom rates for zone 2019 N , echo=FALSE, message=TRUE, warning=FALSE}

N_zones_2019_GSP_rec_rate <- All_zone_rates_2019 %>%
  filter(Strip_Type == "N Strip") %>%
  filter(GSP == "GSP") %>%
  dplyr::select(Paddock_ID, 
                Zone_ID, 
                Total_N,
                #Colwell,
                #DGT,
                #PBI,
                Rec_N_jax,
                GSP,
                Total_sum_N_content,
                #Total_sum_P_content,
                rainfall_class 
                ) %>%
  distinct(Zone_ID, .keep_all = TRUE)
N_zones_2019_GSP_rec_rate$rainfall_class <- factor(N_zones_2019_GSP_rec_rate$rainfall_class, 
                                                            levels = c("low", "medium", "high"))

N_zones_2019_GSP_rec_rate %>%  group_by(rainfall_class) %>%
  summarise(Av_N_Total_N = mean(Total_N, na.rm = TRUE),
            Av_N_rec_rate = mean(Rec_N_jax, na.rm = TRUE),
            Av_N_GSP = mean(Total_sum_N_content, na.rm = TRUE),
            count = n()
  ) 
```

### 2020 P zones 



```{r GSP recom rates for zone 2020 P, echo=FALSE, message=TRUE, warning=FALSE}

## pull out P strip only that has GSP, only keep zone data
P_zones_2020_GSP_rec_rate <- All_zone_rates_2020 %>%
  filter(Strip_Type == "P Strip") %>%
  filter(GSP == "GSP") %>%
  dplyr::select(Paddock_ID, 
                Zone_ID, 
                #Total_N,
                Colwell,
                DGT,
                PBI,
                p_rec,
                #Rec_N_jax,
                GSP,
                #Total_sum_N_content,
                Total_sum_P_content,
                rainfall_class 
                ) %>%
  distinct(Zone_ID, .keep_all = TRUE)

P_zones_2020_GSP_rec_rate$rainfall_class <- factor(P_zones_2020_GSP_rec_rate$rainfall_class, 
                                                            levels = c("low", "medium", "high"))


P_zones_2020_GSP_rec_rate %>%  group_by(rainfall_class) %>%
  summarise(Av_P_Colwell = mean(Colwell, na.rm = TRUE),
            Av_P_DGT = mean(DGT, na.rm = TRUE),
            Av_P_PBI = mean(PBI, na.rm = TRUE),
            Av_P_rec_rate = mean(p_rec, na.rm = TRUE),
            Av_P_GSP = mean(Total_sum_P_content, na.rm = TRUE),
            count = n()
           
  )

```


### 2020 N zones





```{r r GSP recom rates for zone 2020 N , echo=FALSE, message=TRUE, warning=FALSE}

N_zones_2020_GSP_rec_rate <- All_zone_rates_2020 %>%
  filter(Strip_Type == "N Strip") %>%
  filter(GSP == "GSP") %>%
  dplyr::select(Paddock_ID, 
                Zone_ID, 
                Total_N,
                #Colwell,
                #DGT,
                #PBI,
                Rec_N_jax,
                #p_rec_jax,
                GSP,
                Total_sum_N_content,
                #Total_sum_P_content,
                rainfall_class 
                ) %>%
  distinct(Zone_ID, .keep_all = TRUE)
N_zones_2020_GSP_rec_rate$rainfall_class <- factor(N_zones_2020_GSP_rec_rate$rainfall_class, 
                                                            levels = c("low", "medium", "high"))

N_zones_2020_GSP_rec_rate %>%  group_by(rainfall_class) %>%
  summarise(Av_N_Total_N = mean(Total_N, na.rm = TRUE),
            Av_N_rec_rate = mean(Rec_N_jax, na.rm = TRUE),
            Av_N_GSP = mean(Total_sum_N_content, na.rm = TRUE),
            count = n()
  ) 

```





# Case studies for workshop and for report.

#### case study 1

```{r 2020 case study 1, echo=FALSE, message=TRUE, warning=FALSE}

case_study1 <- All_zone_rates_2020 %>% 
  filter(Paddock_ID == "53541") %>% 
  dplyr::select(Strip_Type,
                Zone_ID,
                Paddock_tested,
                Total_N,
                Colwell,
                DGT,
                p_rec,
                Rec_N_jax,
                Total_sum_N_content,
                Total_sum_P_content,
                Yld,
                GM,
                GSP,
                rec_rate_approx_p,
                rec_rate_approx_n)%>% 
  arrange(Zone_ID, Total_sum_P_content)


## make a table that has zone 1 and zone 2
#test results, rec rate, GSP, Yld and GM, P inputs

case_study1_zone_details <- case_study1 %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
#dplyr::select(Strip_Type,Total_N, Rec_N_jax, rec_rate_approx_n)
dplyr::select(Zone_ID, Colwell, DGT, p_rec, rec_rate_approx_p) 

case_study1_zone_details

case_study1_P <- case_study1 %>% 
  mutate(Yld = round(Yld, 1),
         GM = round(GM, 0)) %>% 
  dplyr::select(Zone_ID, Total_sum_P_content, Yld , GM , GSP, rec_rate_approx_p) 

case_study1_P

```

### Case study 1 with an average across the zones

```{r 2020 case study 1 av zones, echo=FALSE, message=TRUE, warning=FALSE}
case_study1_P %>%  group_by(Total_sum_P_content) %>% 
  summarise(av_yld_zone = mean(Yld, na.rm = TRUE),
            av_GM_zone = mean(GM, na.rm = TRUE))
            
```

### Case study 2

```{r 2020 case study 2, echo=FALSE, message=TRUE, warning=FALSE}

case_study2 <- All_zone_rates_2020 %>% 
  filter(Paddock_ID == "31726") %>% 
  dplyr::select(Strip_Type,
                Zone_ID,
                Paddock_tested,
                Total_N,
                Colwell,
                DGT,
                p_rec,
                Rec_N_jax,
                Total_sum_N_content,
                Total_sum_P_content,
                Yld,
                GM,
                GSP,
                rec_rate_approx_p,
                rec_rate_approx_n)%>% 
  arrange(Zone_ID, Total_sum_N_content)


## make a table that has zone 1 and zone 2
#test results, rec rate, GSP, Yld and GM, P inputs

case_study2_zone_details <- case_study2 %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
dplyr::select(Zone_ID, Strip_Type,Paddock_tested,Total_N, Rec_N_jax, rec_rate_approx_n)
#dplyr::select(Zone_ID, Colwell, DGT, p_rec, rec_rate_approx_p) 

case_study2_zone_details

case_study2_N <- case_study2 %>% 
  mutate(Yld = round(Yld, 1),
         GM = round(GM, 0) ,
        Total_sum_N_content = round(Total_sum_N_content, 0))%>% 
  dplyr::select(Zone_ID, Total_sum_N_content, Yld , GM , GSP, rec_rate_approx_n) 

case_study2_N



```

### Case study 2 with an average across the zones

```{r 2020 case study 2 av zones, echo=FALSE, message=TRUE, warning=FALSE}
case_study2_N %>%  group_by(Total_sum_N_content) %>% 
  summarise(av_yld_zone = mean(Yld, na.rm = TRUE),
            av_GM_zone = mean(GM, na.rm = TRUE))
            
```


## Did the soil test recommendations lead to greater gross margins?

We don't always have a match with the recommeded rates and what as applied.
So we have calculated the best match based on:
  how much N / P was applied in the season (or we were told about)
what the recommended rate was calculated from the soil test.


```{r 2019 GM P plots GSP vs approx, echo=FALSE, message=TRUE, warning=FALSE}

#All_zone_rates_2019  
GM_t.test_details_rec_rates2019 <- All_zone_rates_2019 
### remove all the zones / strips that are classed as other, ie they are not the GSP or the approx rec rate.
#unique(GM_t.test_details_rec_rates2019$GSP_Rec_both_p)
GM_t.test_details_rec_rates2019$GSP_Rec_both_p <- as.character(GM_t.test_details_rec_rates2019$GSP_Rec_both_p)
GM_t.test_details_rec_rates2019  <- GM_t.test_details_rec_rates2019 %>% 
  mutate(GM = case_when(
    GM < 0 ~ 0,
    TRUE ~ GM
  ))

################ P Strips #####################################
## only keep P strips that are either rec rate GSP or both
P_approx_GSP_zone_strip_2019 <- GM_t.test_details_rec_rates2019 %>%  
  filter(Strip_Type == "P Strip") %>% 
  filter(GSP_Rec_both_p !=  "other")
#str(P_approx_GSP_zone_strip_2019)
#View(P_approx_GSP_zone_strip_2019)
P_approx_GSP_zone_strip_2019$GSP_Rec_both_p <- as.character(P_approx_GSP_zone_strip_2019$GSP_Rec_both_p)
#unique(P_approx_GSP_zone_strip_2019$GSP_Rec_both_p)

P_approx_GSP_zone_strip_2019$rainfall_class <- factor(P_approx_GSP_zone_strip_2019$rainfall_class, levels = c("low", "medium", "high"))

P_approx_GSP_zone_strip_2019 %>%  
  filter( GSP_Rec_both_p !=  "both" ) %>% 
  ggplot(aes(x = rainfall_class, y = GM, fill = GSP_Rec_both_p)) +
  geom_col(position = "dodge")+
  theme_bw()+
  labs(x = "rainfall class", y = "GM $/ha",
       title = "P 2019",
       subtitle = "Only for zones which the approx rec rate if different to the GSP  ")



```


```{r 2019 GM N plots GSP vs approx, echo=FALSE, message=TRUE, warning=FALSE}

#All_zone_rates_2019  
GM_t.test_details_rec_rates2019 <- All_zone_rates_2019 
### remove all the zones / strips that are classed as other, ie they are not the GSP or the approx rec rate.
unique(GM_t.test_details_rec_rates2019$GSP_Rec_both_n)
GM_t.test_details_rec_rates2019$GSP_Rec_both_n <- as.character(GM_t.test_details_rec_rates2019$GSP_Rec_both_n)
GM_t.test_details_rec_rates2019  <- GM_t.test_details_rec_rates2019 %>% 
  mutate(GM = case_when(
    GM < 0 ~ 0,
    TRUE ~ GM
  ))

################ N Strips #####################################
## only keep N strips that are either rec rate GSP or both
N_approx_GSP_zone_strip_2019 <- GM_t.test_details_rec_rates2019 %>%  
  filter(Strip_Type == "N Strip") %>% 
  filter(GSP_Rec_both_n !=  "other")
# str(N_approx_GSP_zone_strip)
# View(N_approx_GSP_zone_strip)
N_approx_GSP_zone_strip_2019$GSP_Rec_both_n <- as.character(N_approx_GSP_zone_strip_2019$GSP_Rec_both_n)
#unique(N_approx_GSP_zone_strip$GSP_Rec_both_n)

N_approx_GSP_zone_strip_2019$rainfall_class <- factor(N_approx_GSP_zone_strip_2019$rainfall_class, levels = c("low", "medium", "high"))

N_approx_GSP_zone_strip_2019 %>%  
  filter( GSP_Rec_both_n !=  "both" ) %>% 
  ggplot(aes(x = rainfall_class, y = GM, fill = GSP_Rec_both_n)) +
  geom_col(position = "dodge")+
  theme_bw()+
  labs(x = "rainfall class", y = "GM $/ha",
       title = "N 2019",
       subtitle = "Only for zones which the approx rec rate if different to the GSP  ")



```

2020


```{r 2020 GM P plots GSP vs approx, echo=FALSE, message=TRUE, warning=FALSE}

#All_zone_rates_2020  
GM_t.test_details_rec_rates2020 <- All_zone_rates_2020 
### remove all the zones / strips that are classed as other, ie they are not the GSP or the approx rec rate.
#unique(GM_t.test_details_rec_rates2019$GSP_Rec_both_p)
GM_t.test_details_rec_rates2020$GSP_Rec_both_p <- as.character(GM_t.test_details_rec_rates2020$GSP_Rec_both_p)
GM_t.test_details_rec_rates2020  <- GM_t.test_details_rec_rates2020 %>% 
  mutate(GM = case_when(
    GM < 0 ~ 0,
    TRUE ~ GM
  ))

################ P Strips #####################################
## only keep P strips that are either rec rate GSP or both
P_approx_GSP_zone_strip_2020 <- GM_t.test_details_rec_rates2020 %>%  
  filter(Strip_Type == "P Strip") %>% 
  filter(GSP_Rec_both_p !=  "other")
#str(P_approx_GSP_zone_strip_2020)
#View(P_approx_GSP_zone_strip_2020)
P_approx_GSP_zone_strip_2020$GSP_Rec_both_p <- as.character(P_approx_GSP_zone_strip_2020$GSP_Rec_both_p)
#unique(P_approx_GSP_zone_strip_2020$GSP_Rec_both_p)

P_approx_GSP_zone_strip_2020$rainfall_class <- factor(P_approx_GSP_zone_strip_2020$rainfall_class, levels = c("low", "medium", "high"))

P_approx_GSP_zone_strip_2020 %>%  
  filter( GSP_Rec_both_p !=  "both" ) %>% 
  ggplot(aes(x = rainfall_class, y = GM, fill = GSP_Rec_both_p)) +
  geom_col(position = "dodge")+
  theme_bw()+
  labs(x = "rainfall class", y = "GM $/ha",
       title = "P 2020",
       subtitle = "Only for zones which the approx rec rate if different to the GSP  ")



```


```{r 2020 GM N plots GSP vs approx, echo=FALSE, message=TRUE, warning=FALSE}

#All_zone_rates_2020  
GM_t.test_details_rec_rates2020 <- All_zone_rates_2020 
### remove all the zones / strips that are classed as other, ie they are not the GSP or the approx rec rate.
unique(GM_t.test_details_rec_rates2020$GSP_Rec_both_n)
GM_t.test_details_rec_rates2020$GSP_Rec_both_n <- as.character(GM_t.test_details_rec_rates2020$GSP_Rec_both_n)
GM_t.test_details_rec_rates2020  <- GM_t.test_details_rec_rates2020 %>% 
  mutate(GM = case_when(
    GM < 0 ~ 0,
    TRUE ~ GM
  ))

################ N Strips #####################################
## only keep N strips that are either rec rate GSP or both
N_approx_GSP_zone_strip_2020 <- GM_t.test_details_rec_rates2020 %>%  
  filter(Strip_Type == "N Strip") %>% 
  filter(GSP_Rec_both_n !=  "other")
# str(N_approx_GSP_zone_strip)
# View(N_approx_GSP_zone_strip)
N_approx_GSP_zone_strip_2020$GSP_Rec_both_n <- as.character(N_approx_GSP_zone_strip_2020$GSP_Rec_both_n)
#unique(N_approx_GSP_zone_strip$GSP_Rec_both_n)

N_approx_GSP_zone_strip_2020$rainfall_class <- factor(N_approx_GSP_zone_strip_2020$rainfall_class, levels = c("low", "medium", "high"))

N_approx_GSP_zone_strip_2020 %>%  
  filter( GSP_Rec_both_n !=  "both" ) %>% 
  ggplot(aes(x = rainfall_class, y = GM, fill = GSP_Rec_both_n)) +
  geom_col(position = "dodge")+
  theme_bw()+
  labs(x = "rainfall class", y = "GM $/ha",
       title = "N 2020",
       subtitle = "Only for zones which the approx rec rate if different to the GSP  ")



```
