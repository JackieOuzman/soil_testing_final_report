---
title: "Summary for final report"
author: "Jackie Ouzman"
date: "08/09/2021"
output: html_document
---
```{r load library, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


library(tidyverse)
library(ggplot2)

library(formattable)
library(sf)
library(readxl)


library(gt)
library(glue)


library(rnaturalearth)


library(readr)

library(DT)
library(plotKML)
library(knitr)
library(png)


library(magick)


```

## Number of N and P trials for 2020 -2021  season 

CSIRO team have been supplied with spatial data for the location of strip trials.
Along with this information we have details on the type of trial (either N or P) and the fertilisers used.



Note that a few paddocks have both N and P trials.



Most paddocks have two zone, but some have just one and some have multiple zone.
This is filtering data out that is marked excluded from analysis and ensured I am only keeping unique Zone ID.

```{r zone shapefile 2020, message=TRUE, warning=FALSE, include=FALSE}
zone2020 <- st_read("W:/value_soil_testing_prj/Yield_data/2020/All_Zones_2020_wgs84.shp")


zone2020_df <- data.frame(zone2020)
zone2020_1 <- zone2020_df %>% dplyr::select(-geometry)


## some paddocks are excluded from the analysis
zone2020_df <- zone2020_1 %>% 
  filter(Status != "Excluded from Analysis")
#just keep a few clms
names(zone2020_df)
zone2020_df <- zone2020_df %>% 
  dplyr::select(Zone_ID,
                Strip_Type,
                Status,
                organisati,
                contact, 
                farmer,
                paddock)
rm(zone2020, zone2020_1)


zone2020_unique <- zone2020_df %>% 
  distinct(Zone_ID, Strip_Type, .keep_all = TRUE)

#how many zones with N / P strips?
zone2020_count <- zone2020_unique %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>%
  group_by(Strip_Type) %>% 
  summarise(count_zones_by_type = n())



```

2020 season. Zone per fertilsier strip type (using zone shapefile).

```{r  numb strip trials, echo=FALSE, message=TRUE, warning=FALSE}

zone2020_count

```

2020 season.Paddocks per fertilsier strip type.

```{r zone 2020 per paddock, message=TRUE, warning=FALSE, include=FALSE}
#how many paddocks with N / P strips?

names(zone2020_unique)
#I cant just select paddock names beacuse some have the same name house and creek

zone_paddocks <- zone2020_unique %>%
  dplyr::mutate(paddock_farmer = paste0(paddock, "_", farmer)) %>% 
  dplyr::distinct(paddock_farmer, Strip_Type, .keep_all = TRUE)
  
zone_paddocks 
 
count_paddock <- zone_paddocks %>% 
  group_by(Strip_Type) %>% 
  summarise(count_paddocks_by_type = n())

```


```{r  numb paddocks, echo=FALSE, message=TRUE, warning=FALSE}

count_paddock


```


2020 season. How many growers?

```{r zone 2020 per farmers, message=TRUE, warning=FALSE, include=FALSE}

farmers_dist <- zone2020_unique %>% 
  dplyr::distinct(farmer,Strip_Type, .keep_all = TRUE)

farmers_count_type <- farmers_dist %>% 
    group_by(Strip_Type) %>% 
  summarise(count_farmers_by_type = n())

farmers_count <- farmers_dist %>% 
    summarise(count_farmers_by_type = n())



```

```{r number of farmers 2020, echo=FALSE, message=TRUE, warning=FALSE}
farmers_count
```


I can run the same analysis with the strip files but the numbers are slightly different because of the trials that have N and P.
So I will use the zone shapefile as a basis.
The code is here but I am not displaying the output.


```{r load_data1, message=TRUE, warning=FALSE, include=FALSE}

#note that this script runs off the shapefile and has on intermediate steps


spatial_data_no_yld <- st_read("W:/value_soil_testing_prj/Yield_data/2020/All_Strips_2020_wgs84.shp")

spatial <-  st_as_sf(spatial_data_no_yld, coords = c("X", "Y"), crs = 4326) #this is for map in later code chuck

spatial_data_no_yld_df <- data.frame(spatial_data_no_yld)
spatial_data_no_yld_df_1 <- spatial_data_no_yld_df %>% dplyr::select(-geometry)

## some paddocks are excluded from the analysis
spatial_data_no_yld_df <- spatial_data_no_yld_df_1 %>% 
   filter(Status != "Excluded from Analysis")

spatial_data_no_yld_df <- spatial_data_no_yld_df %>% 
  dplyr::mutate(ID_Rate_GSP_type = paste0(Paddock_ID, "-", Rate, "-", GSP,"-",Strip_Type ),
         ID_trial_type = paste0(Paddock_ID, "-",Strip_Type))

spatial_data_no_yld_df <-spatial_data_no_yld_df %>% 
  dplyr::mutate(Alt_GSP = ifelse(stringr::str_detect(GSP_list, "Alt GSP"), "Alt_GPS", "No_Alt_GSP"))

rm(spatial_data_no_yld_df_1)

strips_distinct_paddockID <- spatial_data_no_yld_df %>% 
  distinct(Paddock_ID, Strip_Type, .keep_all = TRUE)

```

```{r plot numb trials, message=TRUE, warning=FALSE, include=FALSE}
plot1 <-
  dplyr::distinct(strips_distinct_paddockID, Paddock_ID ,Strip_Type, .keep_all = TRUE) %>%
  dplyr::select(Paddock_ID, Strip_Type, Alt_GSP) %>%
  ggplot(aes(Strip_Type)) +
  geom_bar() +
  theme_bw() +
  geom_text(aes(y = ((..count..)), label = ((..count..))), stat = "count", vjust = -0.25) +
  labs(
    title = "Number of P and N trials. 2020 to 2021 season",
    y = "Count",
    x = "Type of trial",
    subtitle = paste0("Total number of paddocks = ", count(
      distinct(spatial_data_no_yld_df, ID_trial_type)
    ))
  )
plot1


```




## Number of N and P trials for 2019 -2020  season 

```{r zone shapefile 2019, message=TRUE, warning=FALSE, include=FALSE}
zone2019 <- st_read("W:/value_soil_testing_prj/Yield_data/finished/GIS_Results/All_Zones_2019_wgs84.shp")


zone2019_df <- data.frame(zone2019)
zone2019_1 <- zone2019_df %>% dplyr::select(-geometry)


## some paddocks are excluded from the analysis

#just keep a few clms

zone2019_df <- zone2019_1 %>% 
  dplyr::select(Zone_ID,
                Strip_Type, # I need to add this in ??
                #Status,
                organisati,
                contact, 
                farmer,
                paddock)
rm(zone2019, zone2019_1)


zone2019_df_unique <- zone2019_df %>% 
  distinct(Zone_ID, Strip_Type, .keep_all = TRUE)

#how many zones with N / P strips?
zone2019_count <- zone2019_df_unique %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>%
  group_by(Strip_Type) %>% 
  summarise(count_zones_by_type = n())



```

2019 season. Zone per fertilsier strip type (using zone shapefile).

```{r  numb strip trials 2019, echo=FALSE, message=TRUE, warning=FALSE}

zone2019_count

```

2019 season.Paddocks per fertilsier strip type.

```{r zone 2019 per paddock, message=TRUE, warning=FALSE, include=FALSE}
#how many paddocks with N / P strips?


zone_paddocks2019 <- zone2019_df_unique %>%
  dplyr::mutate(paddock_farmer = paste0(paddock, "_", farmer)) %>% 
  dplyr::distinct(paddock_farmer, Strip_Type, .keep_all = TRUE)

paddocks2019 <-  zone_paddocks2019 %>% 
  group_by(Strip_Type) %>% 
  summarise(count_paddocks_by_type = n())


```


```{r  numb paddocks 2019, echo=FALSE, message=TRUE, warning=FALSE}

paddocks2019

```


2019 season. How many growers?

```{r zone 2019 per farmers, message=TRUE, warning=FALSE, include=FALSE}


farmers_dist2019 <- zone2019_df_unique %>% 
  dplyr::distinct(farmer,Strip_Type, .keep_all = TRUE)

farmers_count_type2019 <- farmers_dist2019 %>% 
  group_by(Strip_Type) %>% 
  summarise(count_farmers_by_type = n())

farmers_count2019 <- farmers_dist2019 %>% 
  summarise(count_farmers = n())



```

```{r number of farmers 2019, echo=FALSE, message=TRUE, warning=FALSE}

farmers_count_type2019
farmers_count2019
```




## How do the recommended rates 2020 -2021  season compare in the multiple zones in the paddock

I have used the low, medium, high rainfall class generated by the location of the trial.

Rather than using the database, which has some odd rainfall classifications.
Note Sean has not used the rainfall classification in the DB to generate his N recommendation.
Sean has used a different rainfall class and his N recommendation (that he has used for analysis and presentations sit outside of the database)
I have redone the N recommendation based on the revised rainfall class.
This revised rainfall class is based on the spatial location of the paddocks.
Using this with BOM average rainfall grid and low med and high class defined by Therese.

Sean is still getting back to me regarding how to calculate the P recommendation.
Looks like there might be an issue with the P recommendation, I have re calculated them.

I am still waiting for confirmation from Sean.



```{r stuff around getting recom rates just for our 2020 paddocks, message=TRUE, warning=FALSE, include=FALSE}
#Get this from the scrap notes 4 should be 2 files.
# I will add the code in here but for now I will just use this file
##########################################################################################################
##### scrap_notes4_2020.R
##########################################################################################################

## getting the yield difference and GM difference between GSP and Approx

all_strips2020 <- st_read("W:/value_soil_testing_prj/Yield_data/2020/All_Strips_2020_wgs84.shp")
#names(all_strips2020)
all_strips2020 <- all_strips2020 %>%
  dplyr::select(Paddock_ID, geometry, 
                Organisation = organisati,
                 Contact = contact,
                 Farmer = farmer,
                 Paddock_tested = paddock,
                Status) 
### remove the paddocks with no reports
#unique(all_strips2020$Status)

all_strips2020 <- all_strips2020 %>%
  dplyr::filter(Status != "Excluded from Analysis")
  
#2.turn polygons into points - centriod
all_strips2020_centroid = st_centroid(all_strips2020)
all_strips2020_centroid <- all_strips2020_centroid %>%  filter(!is.na(Paddock_ID))
#3.
av_rain <- raster::raster("W:/value_soil_testing_prj/Yield_data/2020/processing/rain_grid")

##3a. extract strips coordinates points from the raster (eg shapefile points and average rainfall grid)
all_strips2020_centroid$av_rain <- raster::extract(av_rain, all_strips2020_centroid)
all_strips2020_centroid_df <- as.data.frame(all_strips2020_centroid ) %>%  dplyr::select(-geometry)
rm(all_strips2020, all_strips2020_centroid, av_rain)


## add in GRDC zone
zone2020_GRDC_bound <- st_read("W:/value_soil_testing_prj/Yield_data/2020/2020_GRDC_zones_test.shp")


zone2020_GRDC_bound <- zone2020_GRDC_bound %>% 
  dplyr::select(Zone_ID,
                AGROECOLOG)
zone2020_GRDC_bound <- as.data.frame(zone2020_GRDC_bound) %>% 
  dplyr::select(- geometry)
##make a paddock_ID clm
zone2020_GRDC_bound$length_zoneID <- nchar(zone2020_GRDC_bound$Zone_ID)
zone2020_GRDC_bound <- zone2020_GRDC_bound %>% 
  mutate(Paddock_ID =   
           case_when(length_zoneID == 6 ~ substr(Zone_ID, start = 1, stop = 5),
                     length_zoneID == 7 ~ substr(Zone_ID, start = 1, stop = 6)))
zone2020_GRDC_bound$Paddock_ID <- as.double(zone2020_GRDC_bound$Paddock_ID)

# str(zone2020_GRDC_bound)
# str(all_strips2020_centroid_df)

all_strips2020_centroid_df <- left_join(all_strips2020_centroid_df, zone2020_GRDC_bound)
all_strips2020_centroid_df <- all_strips2020_centroid_df %>% 
  dplyr::mutate(
    rainfall_class = case_when(
      av_rain<=350 ~ "low",
      av_rain >500 ~ "high",
      TRUE ~ "medium"))

#names(all_strips2020_centroid_df)
all_strips2020_centroid_df <- all_strips2020_centroid_df %>% 
  dplyr::select( Paddock_ID,
                 Organisation,
                 Contact,
                 Farmer,Paddock_tested,
                AGROECOLOG, 
                rainfall_class) 
                
### oops I need the rates from the fert df

fertiliser_applied2020 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/step2_fert_app_all_steps.csv")
#str(fertiliser_applied2020)

fert_2020 <- fertiliser_applied2020 %>% 
  dplyr::select(Paddock_ID, Rate,GSP,Strip_Type,
                Total_sum_N_content,
                Total_sum_P_content) 

rm(fertiliser_applied2020, zone2020_GRDC_bound)
#str(all_strips2020_centroid_df)
#str(fert_2020)
## add it to the other data

details_2020 <- left_join(fert_2020, all_strips2020_centroid_df)
rm(fert_2020,all_strips2020_centroid_df )

#names(details_2020)




## Not sure if there is dupliaction only want paddock ID, strip type and rate
details_2020 <- details_2020 %>% 
  dplyr::distinct(Paddock_ID, Strip_Type, Rate, .keep_all = TRUE)

### fix up some problems paddock 52355 has a rate of 82.5 and should be 82

details_2020 <- details_2020 %>% 
  mutate(Rate = case_when(
    Paddock_ID == 52355 & Rate == 82.5 ~ 82,
    TRUE ~ as.double(Rate )))
# this one only had a mud map made remove from analysis
details_2020 <- details_2020 %>% 
  filter(Paddock_ID != 52341)
## I had some strange label in the shapefile
details_2020 <- details_2020 %>% 
  mutate(Rate = case_when(
    Paddock_ID == 52411 & Rate == 400 ~ 9.6,
    Paddock_ID == 52411 & Rate == 800 ~ 19.2,
    Paddock_ID == 52411 & Rate == 8050 ~ 42.2,
    Paddock_ID == 52411 & Rate == 80150 ~ 88.2,
    TRUE ~ as.double(Rate )))

details_2020 <- details_2020 %>% 
  mutate(Rate = case_when(
    Paddock_ID == 524102 & Rate == 33 ~ 3.3,
    Paddock_ID == 524102 & Rate == 5033 ~ 21.0,
    Paddock_ID == 524102 & Rate == 435033 ~ 40.78,
    Paddock_ID == 524102 & Rate == 875033 ~ 61.02,
    Paddock_ID == 524102 & Rate == 1305033 ~ 80.8,
    TRUE ~ as.double(Rate )))

  #######################################################################################

## bring in the t.test data results

set1_2020 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/r_outputs/merged_comparision_output/t_test_merged_3a.csv")

#names(set1_2020)
set1_2020 <- set1_2020 %>% 
  dplyr::select(Zone_ID,
                Rates = Rate,
                Yld = yield,
                P_value,
               Mean_diff,
               rounded,Significant,
               paddock_ID_Type)

t.test_2020 <- set1_2020


##make a paddock_ID clm
t.test_2020$length_zoneID <- nchar(t.test_2020$Zone_ID)
t.test_2020 <- t.test_2020 %>% 
  mutate(Paddock_ID =   
           case_when(length_zoneID == 6 ~ substr(Zone_ID, start = 1, stop = 5),
                     length_zoneID == 7 ~ substr(Zone_ID, start = 1, stop = 6)))
t.test_2020$Paddock_ID <- as.double(t.test_2020$Paddock_ID)

t.test_2020 <- t.test_2020 %>%  
  mutate(part1=str_split_fixed(paddock_ID_Type,"_",2)[,1], Strip_Type=str_split_fixed(paddock_ID_Type,"_",2)[,2])
t.test_2020 <- t.test_2020 %>%
  dplyr::select(- part1)


## I want to join details_2019 to t.test 

# str(t.test_2020)
# str(details_2020)

t.test_2020 <- t.test_2020 %>% 
  dplyr::mutate(for_join = paste0(Paddock_ID, Strip_Type, Rates))

details_2020 <- details_2020 %>% 
  dplyr::mutate(for_join = paste0(Paddock_ID, Strip_Type, Rate))

t.test2020_details <- full_join(details_2020, t.test_2020)
names(t.test2020_details)


## drop the ones that seem to be exluded from analysis ie no conatct
t.test2020_details <- t.test2020_details %>% 
  filter(!is.na(Contact))






t.test2020_details <- t.test2020_details %>%
  dplyr::select(Zone_ID,
                Paddock_ID,
                Strip_Type,
                Rate,
                GSP,
                Strip_Type,
                Total_sum_N_content,
                Total_sum_P_content,
                Yld,
                Organisation,
                Contact,
                Farmer,
                Paddock_tested,
                rainfall_class,
                AGROECOLOG,
                P_value,
                Mean_diff,
                rounded,
                Significant)
#### This is ready for more the recomm rates



####################################################################################################################################################
## bring in rec rates ##


recom_rateDB2020 <- read_excel( "W:/value_soil_testing_prj/data_base/downloaded_sep2021/GRDC 2020 Paddock Database_SA_VIC_June11 2021.xlsx")
#str(recom_rateDB2020)
# select only a few clms with recommedation 
recom_rateDB2020 <- recom_rateDB2020 %>% 
  dplyr::select(Zone_ID =    `Paddock code` ,
                Total_N = `Total N`, 
                p_rec =           `P rec`,
                n_rec_yld_low =   `N Rec (< 3 t/ha)` ,       
                n_rec_yld_med =   `N Rec (3-5 t/ha)` ,             
                n_rec_yld_high =  `N Rec (> 5 t/ha)`,
                Colwell,
                DGT,
                PBI
                
  ) 

recom_rateDB2020$n_rec_yld_low <- as.double(recom_rateDB2020$n_rec_yld_low)
recom_rateDB2020$n_rec_yld_med <- as.double(recom_rateDB2020$n_rec_yld_med)
recom_rateDB2020$n_rec_yld_high <- as.double(recom_rateDB2020$n_rec_yld_high)
recom_rateDB2020$Colwell <- as.double(recom_rateDB2020$Colwell)
recom_rateDB2020$DGT <- as.double(recom_rateDB2020$DGT)
recom_rateDB2020$PBI <- as.double(recom_rateDB2020$PBI)

recom_rateDB2020 <-  dplyr::mutate(recom_rateDB2020,  maxN = apply(recom_rateDB2020[4:6], 1, max, na.rm = TRUE))


# remove redunant clm and replace inf
recom_rateDB2020 <- recom_rateDB2020 %>% 
  mutate(
    maxN = case_when(
      maxN >= 0 ~ maxN,
      TRUE ~ NA_real_
    )
  )

recom_rateDB2020 <- recom_rateDB2020 %>% 
  dplyr::select(Zone_ID  ,
                p_rec ,
                maxN,
                Total_N,
                Colwell,
                DGT,
                PBI)

##make a paddock_ID clm
recom_rateDB2020$length_zoneID <- nchar(recom_rateDB2020$Zone_ID)
recom_rateDB2020 <- recom_rateDB2020 %>% 
  mutate(Paddock_ID =   
           case_when(length_zoneID == 6 ~ substr(Zone_ID, start = 1, stop = 5),
                     length_zoneID == 7 ~ substr(Zone_ID, start = 1, stop = 6)))
recom_rateDB2020$Paddock_ID <- as.double(recom_rateDB2020$Paddock_ID)



rm(details_2020, t.test_2020)

### join the t.test data to the recom rates
# str(recom_rateDB2020)
# str(t.test2020_details)
recom_rateDB2020$Zone_ID <- as.double(recom_rateDB2020$Zone_ID)
t.test_details_rec_rates <- left_join(t.test2020_details, recom_rateDB2020)
rm(recom_rateDB2020, t.test2020_details)
#############################################################################################################
### Redo the rec rates for N with my rainfall zone

t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(Rec_N_jax = case_when(
    rainfall_class == "low" & Total_N <= 80 ~ ((80 -Total_N)/0.5),
    rainfall_class == "medium" & Total_N <= 160 ~ ((160 -Total_N)/0.5),
    rainfall_class == "high" & Total_N <= 240 ~ ((240 -Total_N)/0.5),
    TRUE                           ~ 0  ))

#str(t.test_details_rec_rates)

# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(critical_colwell = 4.6*( PBI^ (0.393)))
# ## is colwell greater than critical colwell?
# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(colwell_thershold = case_when(
#     Colwell > critical_colwell ~ "adequate",
#     Colwell < critical_colwell ~ "p_required")  )
# 
# ## if p is required how much extra colwell p is needed to get to critical thershold?
# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(to_reach_col_thershold = case_when(
#     colwell_thershold == "p_required" ~ critical_colwell - Colwell))
# 
# ## what is the recomm P rate?
# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(p_rec_jax = case_when(
#     colwell_thershold == "p_required" ~ ((0.0019*PBI+2.146)*to_reach_col_thershold),
#     colwell_thershold == "adequate" ~ 5
#     ))
# ## clean up extra clms
# 
# names(t.test_details_rec_rates)
# 
# t.test_details_rec_rates <- t.test_details_rec_rates %>%
#   dplyr::select(-"length_zoneID",
#                 - critical_colwell,
#                 - colwell_thershold,
#                 - to_reach_col_thershold)


###################################################################################################################################
#write this out 
# write.csv(t.test_details_rec_rates, "W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/t.test_details_rec_rates_2020.csv")


##########################################################################################################
##### scrap_notes4_2020_yld_resposne_economics.R
##########################################################################################################
t.test_details_rec_rates_20 <- t.test_details_rec_rates


#########################################################################################################################################################
### 1. bring in the data
t.test_details_rec_rates_20 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/t.test_details_rec_rates_2020.csv")
# t.test_details_rec_rates_20 <- t.test_details_rec_rates
#########################################################################################################################################################
### 2. remove the alt GSP
### all of this analysis will be without the Alt GSP so I will remove it
#str(t.test_details_rec_rates_20)

#unique(t.test_details_rec_rates_20$GSP)
t.test_details_rec_rates_20$GSP <- as.character(t.test_details_rec_rates_20$GSP)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  filter(GSP == "GSP" | is.na(GSP))
#unique(t.test_details_rec_rates_20$GSP)
### difference between p rec and p applied

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(diff_p_rec_applied = abs(Total_sum_P_content- p_rec))
closest_match_p <-t.test_details_rec_rates_20 %>%
  group_by(Zone_ID) %>% 
  summarise(closest_match_p = min(diff_p_rec_applied))


#Add this back in

t.test_details_rec_rates_20 <- left_join(t.test_details_rec_rates_20, closest_match_p)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(rec_rate_approx_p =
           case_when(
             closest_match_p == diff_p_rec_applied ~ "approx_rec_rate"))

unique(t.test_details_rec_rates_20$GSP)
t.test_details_rec_rates_20$GSP <- as.character(t.test_details_rec_rates_20$GSP)

str(t.test_details_rec_rates_20$GSP)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(GSP_Rec_both_p = case_when(
    GSP == "GSP"  & rec_rate_approx_p == "approx_rec_rate" ~ "both",
    is.na(GSP)            & rec_rate_approx_p == "approx_rec_rate" ~ "rec_rate",
    GSP == "GSP"  & is.na(rec_rate_approx_p) ~ "GSP",
    TRUE ~ "other"
  ))


### difference between N rec and N applied
names(t.test_details_rec_rates_20)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(diff_n_rec_applied = abs(Total_sum_N_content- Rec_N_jax))

closest_match_n <-t.test_details_rec_rates_20 %>%
  group_by(Zone_ID) %>% 
  summarise(closest_match_n = min(diff_n_rec_applied))


#Add this back in


t.test_details_rec_rates_20 <- left_join(t.test_details_rec_rates_20, closest_match_n)
str(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(rec_rate_approx_n =
           case_when(
             closest_match_n == diff_n_rec_applied ~ "approx_rec_rate"))



t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(GSP_Rec_both_n = case_when(
    GSP == "GSP"  & rec_rate_approx_n == "approx_rec_rate" ~ "both",
    is.na(GSP)            & rec_rate_approx_n == "approx_rec_rate" ~ "rec_rate",
    GSP == "GSP"  & is.na(rec_rate_approx_n) ~ "GSP",
    TRUE ~ "other"
  ))








#### arrange the data so that I have the order of detail that reflects it.
names(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::select(

#Tier 1
Paddock_ID,
Strip_Type,
Organisation,
Contact,
Farmer,
Paddock_tested,
rainfall_class,
AGROECOLOG,

#Tier 2
Zone_ID,
Total_N,
Colwell,
DGT,
PBI,
p_rec,
maxN,
Rec_N_jax,
#p_rec_jax,
 
#Tier 3
Rate,
GSP,
Total_sum_N_content,
Total_sum_P_content,
Yld,
P_value,
Mean_diff,
rounded,
Significant,

#Tier 3 details# 
diff_p_rec_applied,
closest_match_p,
rec_rate_approx_p,
GSP_Rec_both_p,
diff_n_rec_applied,
closest_match_n,
rec_rate_approx_n,
GSP_Rec_both_n
)    



##############################################################################
### add some GM to yld results 
##############################################################################
# convert the yield to income of grain $/ha
# this assumes that all yield is in t /ha 
# all crops are wheat
# the 5 year wheat average is $286 and is same for all sites.
names(df)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% mutate(grain_income = Yld * 286)

##############################################################################
## cost for test $3 per ha for rates the approx rate here some GSP are also approx rec rate labelled as both

names(t.test_details_rec_rates_20)
unique(t.test_details_rec_rates_20$GSP_Rec_both_p)
unique(t.test_details_rec_rates_20$GSP_Rec_both_n)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% mutate(cost_test = case_when(
  GSP_Rec_both_p == "rec_rate" ~ 3.00,
  GSP_Rec_both_p == "both" ~ 3.00,
  
  GSP_Rec_both_n == "rec_rate" ~ 3.00,
  GSP_Rec_both_n == "both" ~ 3.00,
  TRUE ~ 0.00))

## cost fert is based on rainfall class - define the rainfall class

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::mutate(
    variable_costs = case_when(
      Strip_Type == "P Strip" & rainfall_class == "low" ~     194,
      Strip_Type == "P Strip" & rainfall_class == "medium" ~  358,
      Strip_Type == "P Strip" & rainfall_class == "high" ~    540,
      
      Strip_Type == "N Strip" & rainfall_class == "low" ~     220,
      Strip_Type == "N Strip" & rainfall_class == "medium" ~  340,
      Strip_Type == "N Strip" & rainfall_class == "high" ~    498))

### I don't get this step but it converts N applied from kg/ha to cost of N $ha
str(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::mutate(
    Cost_P_N_dollar_ha  = case_when(
      Strip_Type == "P Strip"  ~     Total_sum_P_content * 2.9,
      Strip_Type == "N Strip"  ~     Total_sum_N_content * 1.1))     

## GM
#GM = Income grain – cost test – variable cost – cost of N


t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::mutate(
    total_cost = cost_test + variable_costs + Cost_P_N_dollar_ha,
    GM  = grain_income - total_cost)

names(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::select(-diff_p_rec_applied,
                -diff_n_rec_applied,
                -closest_match_p,
                -closest_match_n,
                -grain_income,
                -cost_test,
                -variable_costs,
                -Cost_P_N_dollar_ha,
                -total_cost  )

#write.csv(t.test_details_rec_rates_20, "W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/GM_t.test_details_rec_rates2020.csv")


##########################################################################################################
##### scrap_notes4_2020_yld_resposne_economics.R
##########################################################################################################

#########################################################################################################################################################
### 1. bring in the data
t.test_details_rec_rates_20 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/t.test_details_rec_rates_2020.csv")
# t.test_details_rec_rates_20 <- t.test_details_rec_rates
#########################################################################################################################################################
### 2. remove the alt GSP
### all of this analysis will be without the Alt GSP so I will remove it
#str(t.test_details_rec_rates_20)

#unique(t.test_details_rec_rates_20$GSP)
t.test_details_rec_rates_20$GSP <- as.character(t.test_details_rec_rates_20$GSP)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  filter(GSP == "GSP" | is.na(GSP))
#unique(t.test_details_rec_rates_20$GSP)
### difference between p rec and p applied

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(diff_p_rec_applied = abs(Total_sum_P_content- p_rec))
closest_match_p <-t.test_details_rec_rates_20 %>%
  group_by(Zone_ID) %>% 
  summarise(closest_match_p = min(diff_p_rec_applied))


#Add this back in

t.test_details_rec_rates_20 <- left_join(t.test_details_rec_rates_20, closest_match_p)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(rec_rate_approx_p =
           case_when(
             closest_match_p == diff_p_rec_applied ~ "approx_rec_rate"))

unique(t.test_details_rec_rates_20$GSP)
t.test_details_rec_rates_20$GSP <- as.character(t.test_details_rec_rates_20$GSP)

str(t.test_details_rec_rates_20$GSP)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(GSP_Rec_both_p = case_when(
    GSP == "GSP"  & rec_rate_approx_p == "approx_rec_rate" ~ "both",
    is.na(GSP)            & rec_rate_approx_p == "approx_rec_rate" ~ "rec_rate",
    GSP == "GSP"  & is.na(rec_rate_approx_p) ~ "GSP",
    TRUE ~ "other"
  ))


### difference between N rec and N applied
names(t.test_details_rec_rates_20)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(diff_n_rec_applied = abs(Total_sum_N_content- Rec_N_jax))

closest_match_n <-t.test_details_rec_rates_20 %>%
  group_by(Zone_ID) %>% 
  summarise(closest_match_n = min(diff_n_rec_applied))


#Add this back in


t.test_details_rec_rates_20 <- left_join(t.test_details_rec_rates_20, closest_match_n)
str(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(rec_rate_approx_n =
           case_when(
             closest_match_n == diff_n_rec_applied ~ "approx_rec_rate"))



t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  mutate(GSP_Rec_both_n = case_when(
    GSP == "GSP"  & rec_rate_approx_n == "approx_rec_rate" ~ "both",
    is.na(GSP)            & rec_rate_approx_n == "approx_rec_rate" ~ "rec_rate",
    GSP == "GSP"  & is.na(rec_rate_approx_n) ~ "GSP",
    TRUE ~ "other"
  ))








#### arrange the data so that I have the order of detail that reflects it.
names(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::select(

#Tier 1
Paddock_ID,
Strip_Type,
Organisation,
Contact,
Farmer,
Paddock_tested,
rainfall_class,
AGROECOLOG,

#Tier 2
Zone_ID,
Total_N,
Colwell,
DGT,
PBI,
p_rec,
maxN,
Rec_N_jax,
#p_rec_jax,
 
#Tier 3
Rate,
GSP,
Total_sum_N_content,
Total_sum_P_content,
Yld,
P_value,
Mean_diff,
rounded,
Significant,

#Tier 3 details# 
diff_p_rec_applied,
closest_match_p,
rec_rate_approx_p,
GSP_Rec_both_p,
diff_n_rec_applied,
closest_match_n,
rec_rate_approx_n,
GSP_Rec_both_n
)    



##############################################################################
### add some GM to yld results 
##############################################################################
# convert the yield to income of grain $/ha
# this assumes that all yield is in t /ha 
# all crops are wheat
# the 5 year wheat average is $286 and is same for all sites.
names(df)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% mutate(grain_income = Yld * 286)

##############################################################################
## cost for test $3 per ha for rates the approx rate here some GSP are also approx rec rate labelled as both

names(t.test_details_rec_rates_20)
unique(t.test_details_rec_rates_20$GSP_Rec_both_p)
unique(t.test_details_rec_rates_20$GSP_Rec_both_n)

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% mutate(cost_test = case_when(
  GSP_Rec_both_p == "rec_rate" ~ 3.00,
  GSP_Rec_both_p == "both" ~ 3.00,
  
  GSP_Rec_both_n == "rec_rate" ~ 3.00,
  GSP_Rec_both_n == "both" ~ 3.00,
  TRUE ~ 0.00))

## cost fert is based on rainfall class - define the rainfall class

t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::mutate(
    variable_costs = case_when(
      Strip_Type == "P Strip" & rainfall_class == "low" ~     194,
      Strip_Type == "P Strip" & rainfall_class == "medium" ~  358,
      Strip_Type == "P Strip" & rainfall_class == "high" ~    540,
      
      Strip_Type == "N Strip" & rainfall_class == "low" ~     220,
      Strip_Type == "N Strip" & rainfall_class == "medium" ~  340,
      Strip_Type == "N Strip" & rainfall_class == "high" ~    498))

### I don't get this step but it converts N applied from kg/ha to cost of N $ha
str(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::mutate(
    Cost_P_N_dollar_ha  = case_when(
      Strip_Type == "P Strip"  ~     Total_sum_P_content * 2.9,
      Strip_Type == "N Strip"  ~     Total_sum_N_content * 1.1))     

## GM
#GM = Income grain – cost test – variable cost – cost of N


t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::mutate(
    total_cost = cost_test + variable_costs + Cost_P_N_dollar_ha,
    GM  = grain_income - total_cost)

names(t.test_details_rec_rates_20)
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20
t.test_details_rec_rates_20 <- t.test_details_rec_rates_20 %>% 
  dplyr::select(-diff_p_rec_applied,
                -diff_n_rec_applied,
                -closest_match_p,
                -closest_match_n,
                -grain_income,
                -cost_test,
                -variable_costs,
                -Cost_P_N_dollar_ha,
                -total_cost  )

# write.csv(t.test_details_rec_rates_20, "W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/GM_t.test_details_rec_rates2020.csv")



All_zone_rates_2020 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/GM_t.test_details_rec_rates2020.csv")

```


For P trials in 2020
The number of paddocks with either 1, 2,3 zones
How many paddocks have a P rec rate in zone 1 vs zone 2 that is higher than 5 kg


```{r rec rates different in zone 2020 P , echo=FALSE, message=TRUE, warning=FALSE}
## pull out P strip only, only keep zone data
P_zones_2020 <- All_zone_rates_2020 %>% 
  filter(Strip_Type == "P Strip") %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:maxN)


# for each paddocks what is the max and min P rec (doesnt matter how many zones)
Zone_In_Paddocks_P_2020 <- P_zones_2020 %>%  group_by(Paddock_ID) %>% 
  summarise(count_zone = n(),
            max_P_rec = max(p_rec, na.rm = FALSE),
            min_P_rec = min(p_rec, na.rm = FALSE))

#difference between high and low
Zone_In_Paddocks_P_2020 <- Zone_In_Paddocks_P_2020 %>% 
  mutate(diff_P_rec_rate = max_P_rec - min_P_rec)

#is the difference greater than 5 then it gets a value of 1
Zone_In_Paddocks_P_2020 <- Zone_In_Paddocks_P_2020 %>% 
  mutate(count_of_diff = case_when(
    count_zone >1 & diff_P_rec_rate >5 ~ 1,
    TRUE ~ 0))
#count how many paddocks have zones with different rec rate that is greater than 5
Zone_In_Paddocks_P_2020 %>%  group_by(count_zone) %>% 
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE))

Zone_In_Paddocks_P_2020 %>%  
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE),
            count =  n(),
            percent_zone_with_diff_rec_P = (sum_of_when_diff/count) *100)

```

For N trials in 2020
The number of paddocks with either 1, 2,3 zones
How many paddocks have a P rec rate in zone 1 vs zone 2 that is higher than 10 kg

Note for the paddocks with the one than 2 zone I have just reported on the max difference.
For example what was the min and max recommedation.  


```{r rec rates different in zone 2020 N, echo=FALSE, message=TRUE, warning=FALSE}
## pull out N strip only, only keep zone data
N_zones_2020 <- All_zone_rates_2020 %>% 
  filter(Strip_Type == "N Strip") %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:Rec_N_jax)


# for each paddocks what is the max and min N rec (doesnt matter how many zones)
Zone_In_Paddocks_N_2020 <- N_zones_2020 %>%  group_by(Paddock_ID) %>% 
  summarise(count_zone = n(),
            max_N_rec = max(Rec_N_jax, na.rm = FALSE),
            min_N_rec = min(Rec_N_jax, na.rm = FALSE))

Zone_In_Paddocks_N_2020 <- Zone_In_Paddocks_N_2020 %>% 
  mutate(diff_N_rec_rate = max_N_rec - min_N_rec)

#is the difference greater than 10 then it gets a value of 1
Zone_In_Paddocks_N_2020 <- Zone_In_Paddocks_N_2020 %>% 
  mutate(count_of_diff = case_when(
    count_zone >1 & diff_N_rec_rate >10 ~ 1,
    TRUE ~ 0))

#count how many paddocks have zones with different rec rate that is greater than 10
Zone_In_Paddocks_N_2020 %>%  group_by(count_zone) %>% 
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE))

Zone_In_Paddocks_N_2020 %>%  
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE),
            count =  n(),
            percent_zone_with_diff_rec_N = (sum_of_when_diff/count) *100)

```



## How do the recommended rates 2019 -2020  season compare in the multiple zones in the paddock
I have now used updated calculation.
I am still waiting on Sean to confirm that my P recommendation calculation is correct.


```{r stuff around getting  2019 data, message=TRUE, warning=FALSE, include=FALSE}

#Get this from the scrap notes 4 should be 2 files.
# I will add the code in here but for now I will just use this file

### scrap_notes4_2016


## getting the yield difference and GM difference between GSP and Approx
all_strips2019 <- st_read("W:/value_soil_testing_prj/Yield_data/finished/GIS_Results/All_Strips_2019_wgs84.shp")
all_strips2019 <- all_strips2019 %>%
  dplyr::select(Paddock_ID, geometry) 

#2.turn polygons into points - centriod
all_strips2019_centroid = st_centroid(all_strips2019)
all_strips2019_centroid <- all_strips2019_centroid %>%  filter(!is.na(Paddock_ID))
#3.
av_rain <- raster::raster("W:/value_soil_testing_prj/Yield_data/2020/processing/rain_grid")

##3a. extract strips coordinates points from the raster (eg shapefile points and average rainfall grid)
all_strips2019_centroid$av_rain <- raster::extract(av_rain, all_strips2019_centroid)
all_strips2019_centroid_df <- as.data.frame(all_strips2019_centroid ) %>%  dplyr::select(-geometry)
rm(all_strips2019, all_strips2019_centroid, av_rain)


## add in GRDC zone
zone2019_GRDC_bound <- st_read("W:/value_soil_testing_prj/Yield_data/finished/GIS_Results/All_Zones_2019_GRDC_wgs84.shp")

zone2019_GRDC_bound <- zone2019_GRDC_bound %>% 
  dplyr::select(Zone_ID,
                AGROECOLOG)
zone2019_GRDC_bound <- as.data.frame(zone2019_GRDC_bound) %>% 
  dplyr::select(- geometry)
##make a paddock_ID clm
zone2019_GRDC_bound$length_zoneID <- nchar(zone2019_GRDC_bound$Zone_ID)
zone2019_GRDC_bound <- zone2019_GRDC_bound %>% 
  mutate(Paddock_ID =   
           case_when(length_zoneID == 6 ~ substr(Zone_ID, start = 1, stop = 5),
                     length_zoneID == 7 ~ substr(Zone_ID, start = 1, stop = 6)))
zone2019_GRDC_bound$Paddock_ID <- as.double(zone2019_GRDC_bound$Paddock_ID)

# str(zone2019_GRDC_bound)
# str(all_strips2019_centroid_df)

all_strips2019_centroid_df <- left_join(all_strips2019_centroid_df, zone2019_GRDC_bound)
all_strips2019_centroid_df <- all_strips2019_centroid_df %>% 
  dplyr::mutate(
    rainfall_class = case_when(
      av_rain<=350 ~ "low",
      av_rain >500 ~ "high",
      TRUE ~ "medium"))


all_strips2019_centroid_df <- all_strips2019_centroid_df %>% 
  dplyr::select( Paddock_ID, 
                AGROECOLOG, 
                rainfall_class) 
                
### oops I need the rates from the fert df

fertiliser_applied2019 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/step2_fert_app_all_step_2019.csv")
#str(fertiliser_applied2019)

fert_2019 <- fertiliser_applied2019 %>% 
  dplyr::select(Paddock_ID, Rate,GSP,Strip_Type,
                Total_sum_N_content,
                Total_sum_P_content) 

rm(fertiliser_applied2019, zone2019_GRDC_bound)
# str(all_strips2019_centroid_df)
# str(fert_2019)
## add it to the other data

details_2019 <- left_join(fert_2019, all_strips2019_centroid_df)
rm(fert_2019,all_strips2019_centroid_df )

# names(details_2019)

## The GSP is coded a bit strange its either a GPS or number - should all be GSP
details_2019 <- details_2019 %>% 
  dplyr::mutate(GSP = case_when(
    GSP =!is.na(GSP) ~ "GSP" 
  ))
#str(details_2019)
## remove a couple of problem strips
details_2019 <- details_2019 %>% 
  filter(Paddock_ID != 31712  |  !is.na(Rate))
details_2019 <- details_2019 %>% 
  filter(Paddock_ID != 51521  |  !is.na(Rate))
details_2019 <- details_2019 %>% 
  filter(Paddock_ID != 51522  |  !is.na(Rate))

#######################################################################################

## bring in the t.test data results

set1_2019 <- read.csv("W:/value_soil_testing_prj/Yield_data/finished/complied/use/Landmark_with_soil2020-06-24_For_TM.csv")
set2_2019 <- read.csv("W:/value_soil_testing_prj/Yield_data/finished/complied/use/Non_landmark_results_soil_and_pair_rates2020-06-25_For_TM.csv")
# str(set1_2019)
# names(set1_2019)
set1_2019 <- set1_2019 %>% 
  dplyr::select(Zone_ID = Paddock.code,
                Organisation,
                Contact,
                Farmer,
                Paddock_tested,
                Rates,
                Yld,
                P_value,Mean_diff,rounded,Significant)

# str(set2_2019)
# names(set2_2019)

set2_2019 <- set2_2019 %>% 
  dplyr::select(Zone_ID = Paddock.code,
                Organisation,
                Contact,
                Farmer,
                Paddock_tested,
                Rates,
                Yld,
                P_value,Mean_diff,rounded,Significant)
# Pole has rates in shapefile that are different to this, its that same but expressed in different units

set2_2019 <- set2_2019 %>%
  dplyr::mutate(Rates = case_when(
    Paddock_tested == 	"Georges" & Rates ==  0 ~ 0,
    Paddock_tested == 	"Georges" & Rates ==  3 ~ 23,
    Paddock_tested == 	"Georges" & Rates ==  6 ~ 46,
    Paddock_tested == 	"Georges" & Rates ==  9 ~ 69,
    Paddock_tested == 	"Georges" & Rates ==  12 ~ 92,
    Paddock_tested == 	"Georges" & Rates ==  15 ~ 115,
    TRUE ~ as.double(Rates)
  ))

t.test_2019 <- rbind(set2_2019, set1_2019)
rm(set1_2019, set2_2019)

##make a paddock_ID clm
t.test_2019$length_zoneID <- nchar(t.test_2019$Zone_ID)
t.test_2019 <- t.test_2019 %>% 
  mutate(Paddock_ID =   
           case_when(length_zoneID == 6 ~ substr(Zone_ID, start = 1, stop = 5),
                     length_zoneID == 7 ~ substr(Zone_ID, start = 1, stop = 6)))
t.test_2019$Paddock_ID <- as.double(t.test_2019$Paddock_ID)



## The t test data does not have N or P Strips and there is duplication
#str(t.test_2019)
t.test_2019 <- t.test_2019 %>% 
  dplyr::mutate(Strip_Type = case_when(
    Paddock_ID == 31132 ~ "N Strip",
    Paddock_ID == 31231 ~ "N Strip",
    Paddock_ID == 31233 ~ "N Strip",
    Paddock_ID == 31711 ~ "N Strip",
    Paddock_ID == 31712 ~ "N Strip",
    Paddock_ID == 31726 ~ "N Strip",
    Paddock_ID == 51512 ~ "N Strip",
    Paddock_ID == 51713 ~ "N Strip",
    Paddock_ID == 51911 ~ "N Strip",
    Paddock_ID == 51914 ~ "N Strip",
    Paddock_ID == 51915 ~ "N Strip",
    Paddock_ID == 52413 ~ "N Strip",
    Paddock_ID == 52444 ~ "N Strip",
    Paddock_ID == 52453 ~ "N Strip",
    Paddock_ID == 51511 ~ "N Strip",
    Paddock_ID == 33311 ~ "N and P Strip",
    Paddock_ID == 33321 ~ "N and P Strip",
    Paddock_ID == 33331 ~ "N and P Strip",
    TRUE ~ "P Strip"
  ))
## Ann paddocks are a bit of a mess some results are for P and some are for N I have used TB analysis to work out which is which
t.test_2019 <- t.test_2019 %>% 
  dplyr::mutate(Strip_Type = case_when(
    #Schlitz_M2
    Zone_ID == 333110 & Rates == 0 & Yld < 3 ~ "N Strip",
    Zone_ID == 333110 & Rates == 60  ~ "N Strip",
    Zone_ID == 333110 & Rates == 120  ~ "N Strip",
    
    Zone_ID == 333110 & Rates == 0 & Yld > 3 ~ "P Strip",
    Zone_ID == 333110 & Rates == 20  ~ "P Strip",
    Zone_ID == 333110 & Rates == 40  ~ "P Strip",
    Zone_ID == 333110 & Rates == 80  ~ "P Strip",
    
    
    #Schlitz_M2
    Zone_ID == 333111 & Rates == 0 & Yld > 2.69 ~ "N Strip",
    Zone_ID == 333111 & Rates == 60  ~ "N Strip",
    Zone_ID == 333111 & Rates == 120  ~ "N Strip",
    
    Zone_ID == 333111 & Rates == 0 & Yld < 2.69 ~ "P Strip",
    Zone_ID == 333111 & Rates == 20  ~ "P Strip",
    Zone_ID == 333111 & Rates == 40  ~ "P Strip",
    Zone_ID == 333111 & Rates == 80  ~ "P Strip",
    
    #Chamberlain_2
    Zone_ID == 333211 & Rates == 25  ~ "P Strip",
    Zone_ID == 333211 & Rates == 50  ~ "P Strip",
    Zone_ID == 333211 & Rates == 75  ~ "P Strip",
    
    Zone_ID == 333210 & Rates == 25  ~ "P Strip",
    Zone_ID == 333210 & Rates == 50  ~ "P Strip",
    Zone_ID == 333210 & Rates == 75  ~ "P Strip",
    
    Zone_ID == 333211 & Rates == 0  ~ "N Strip",
    Zone_ID == 333211 & Rates == 60  ~ "N Strip",
    Zone_ID == 333211 & Rates == 120  ~ "N Strip",
    
    Zone_ID == 333210 & Rates == 0  ~ "N Strip",
    Zone_ID == 333210 & Rates == 60  ~ "N Strip",
    Zone_ID == 333210 & Rates == 120  ~ "N Strip",
    
    
    #Nelson_3
    Zone_ID == 333311 & Rates == 0 & Yld < 1.5 ~ "P Strip",
    Zone_ID == 333311 & Rates == 25 & Yld > 1.5 ~ "P Strip",
    Zone_ID == 333311 & Rates == 50 & Yld < 1.5 ~ "P Strip",
    Zone_ID == 333311 & Rates == 75  ~ "P Strip",
    
    Zone_ID == 333310 & Rates == 0 & Yld > 1.8 ~ "P Strip",
    Zone_ID == 333310 & Rates == 25 & Yld < 1.7 ~ "P Strip",
    Zone_ID == 333310 & Rates == 50 & Yld > 1.7 ~ "P Strip",
    Zone_ID == 333310 & Rates == 75  ~ "P Strip",
    
    Zone_ID == 333311 & Rates == 0 & Yld < 1.5 ~ "N Strip",
    Zone_ID == 333311 & Rates == 25 & Yld > 1.5 ~ "N Strip",
    Zone_ID == 333311 & Rates == 50 & Yld < 1.5 ~ "N Strip",
    
    
    Zone_ID == 333311 & Rates == 0 & Yld > 1.5 ~ "N Strip",
    Zone_ID == 333311 & Rates == 25 & Yld < 1.5 ~ "N Strip",
    Zone_ID == 333311 & Rates == 50 & Yld > 1.5 ~ "N Strip",
    
    Zone_ID == 333310 & Rates == 0 & Yld < 1.8 ~ "N Strip",
    Zone_ID == 333310 & Rates == 25 & Yld > 1.7 ~ "N Strip",
    Zone_ID == 333310 & Rates == 50 & Yld < 1.7 ~ "N Strip",
    
    TRUE ~ Strip_Type
  ))

# is  paddock is missing code "Landmark	James_Falvey_2	Tim_McClelland_4	Mervyns" but I am not sure it should be included??
# names(t.test_2019)
t.test_2019 <- t.test_2019 %>% 
  dplyr::mutate(Zone_ID = case_when(
    Paddock_tested == "Mervyns" ~ 312431,
    TRUE ~ as.double(Zone_ID)
  ) )




## I want to join details_2019 to t.test 

# str(t.test_2019)
# str(details_2019)

t.test_2019 <- t.test_2019 %>% 
  dplyr::mutate(for_join = paste0(Paddock_ID, Strip_Type, Rates))
details_2019 <- details_2019 %>% 
  dplyr::mutate(for_join = paste0(Paddock_ID, Strip_Type, Rate))

t.test2019_details <- full_join(details_2019, t.test_2019)
# names(t.test2019_details)

# I have two problem paddocks Jeff (53621) no rates no analysis and Mervyns non zone 312431 

t.test2019_details <- t.test2019_details %>% 
  filter(Paddock_tested != "Mervyns")
t.test2019_details <- t.test2019_details %>% 
  filter(Paddock_ID != 53621)

t.test2019_details <- t.test2019_details %>%
  dplyr::select(Zone_ID,
                Paddock_ID,
                Strip_Type,
                Rate,
                GSP,
                Strip_Type,
                Total_sum_N_content,
                Total_sum_P_content,
                Yld,
                Organisation,
                Contact,
                Farmer,
                Paddock_tested,
                rainfall_class,
                AGROECOLOG,
                P_value,
                Mean_diff,
                rounded,
                Significant)
#### This is ready for more the recomm rates



####################################################################################################################################################
## bring in rec rates ##

recom_rateDB2019 <- read_excel( "W:/value_soil_testing_prj/data_base/downloaded_sep2021/GRDC 2019 Paddock Database_SA_VIC_June11 2021.xlsx")
# str(recom_rateDB2019)
# select only a few clms with recommedation 
recom_rateDB2019 <- recom_rateDB2019 %>% 
  dplyr::select(Zone_ID =    `Paddock code` ,
                Total_N = `Total N`, 
                p_rec =           `P rec`,
                n_rec_yld_low =   `N Rec (< 3 t/ha)` ,       
                n_rec_yld_med =   `N Rec (3-5 t/ha)` ,             
                n_rec_yld_high =  `N Rec (> 5 t/ha)`,
                Colwell,
                DGT,
                PBI
                
  ) 

recom_rateDB2019$n_rec_yld_low <- as.double(recom_rateDB2019$n_rec_yld_low)
recom_rateDB2019$n_rec_yld_med <- as.double(recom_rateDB2019$n_rec_yld_med)
recom_rateDB2019$n_rec_yld_high <- as.double(recom_rateDB2019$n_rec_yld_high)
recom_rateDB2019$Colwell <- as.double(recom_rateDB2019$Colwell)
recom_rateDB2019$DGT <- as.double(recom_rateDB2019$DGT)
recom_rateDB2019$PBI <- as.double(recom_rateDB2019$PBI)

recom_rateDB2019 <-  dplyr::mutate(recom_rateDB2019,  maxN = apply(recom_rateDB2019[4:6], 1, max, na.rm = TRUE))


# remove redunant clm and replace inf
recom_rateDB2019 <- recom_rateDB2019 %>% 
  mutate(
    maxN = case_when(
      maxN >= 0 ~ maxN,
      TRUE ~ NA_real_
    )
  )

recom_rateDB2019 <- recom_rateDB2019 %>% 
  dplyr::select(Zone_ID  ,
                p_rec ,
                maxN,
                Total_N,
                Colwell,
                DGT,
                PBI)

##make a paddock_ID clm
recom_rateDB2019$length_zoneID <- nchar(recom_rateDB2019$Zone_ID)
recom_rateDB2019 <- recom_rateDB2019 %>% 
  mutate(Paddock_ID =   
           case_when(length_zoneID == 6 ~ substr(Zone_ID, start = 1, stop = 5),
                     length_zoneID == 7 ~ substr(Zone_ID, start = 1, stop = 6)))
recom_rateDB2019$Paddock_ID <- as.double(recom_rateDB2019$Paddock_ID)

# str(recom_rateDB2019) #this has all the zones
# str(fert_2019_rain_GSP) #this has the paddock details

rm(details_2019, t.test_2019)

### join the t.test data to the recom rates
# str(recom_rateDB2019)
# str(t.test2019_details)

t.test_details_rec_rates <- left_join(t.test2019_details, recom_rateDB2019)
rm(recom_rateDB2019, t.test2019_details)
#############################################################################################################
### Redo the rec rates for N with my rainfall zone

t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(Rec_N_jax = case_when(
    rainfall_class == "low" & Total_N <= 80 ~ ((80 -Total_N)/0.5),
    rainfall_class == "medium" & Total_N <= 160 ~ ((160 -Total_N)/0.5),
    rainfall_class == "high" & Total_N <= 240 ~ ((240 -Total_N)/0.5),
    TRUE                           ~ 0  ))

# str(t.test_details_rec_rates)

# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(critical_colwell = 4.6*( PBI^ (0.393)))
# ## is colwell greater than critical colwell?
# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(colwell_thershold = case_when(
#     Colwell > critical_colwell ~ "adequate",
#     Colwell < critical_colwell ~ "p_required")  )

## if p is required how much extra colwell p is needed to get to critical thershold?
# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(to_reach_col_thershold = case_when(
#     colwell_thershold == "p_required" ~ critical_colwell - Colwell))
# 
# ## what is the recomm P rate?
# t.test_details_rec_rates <- t.test_details_rec_rates %>% 
#   mutate(p_rec_jax = case_when(
#     colwell_thershold == "p_required" ~ ((0.0019*PBI+2.146)*to_reach_col_thershold),
#     colwell_thershold == "adequate" ~ 5
#     ))
# ## clean up extra clms
# 
# names(t.test_details_rec_rates)
# 
# t.test_details_rec_rates <- t.test_details_rec_rates %>%
#   dplyr::select(-"length_zoneID",
#                 - critical_colwell,
#                 - colwell_thershold,
#                 - to_reach_col_thershold)


###################################################################################################################################
#write this out 
# write.csv(t.test_details_rec_rates, "W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/t.test_details_rec_rates_2019.csv")



###################################################################################################################################   Scrap_notes4_2019_yld_response_economics.R


# t.test_details_rec_rates <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/t.test_details_rec_rates_2019.csv")
# 
# str(t.test_details_rec_rates)


### difference between p rec and p applied

t.test_details_rec_rates$p_rec <- as.double(t.test_details_rec_rates$p_rec)

t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(diff_p_rec_applied = abs(Total_sum_P_content- p_rec))
closest_match_p <-t.test_details_rec_rates %>%
  group_by(Zone_ID) %>% 
  summarise(closest_match_p = min(diff_p_rec_applied))


#Add this back in

t.test_details_rec_rates <- left_join(t.test_details_rec_rates, closest_match_p)
t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(rec_rate_approx_p =
           case_when(
             closest_match_p == diff_p_rec_applied ~ "approx_rec_rate"))

unique(t.test_details_rec_rates$GSP)
t.test_details_rec_rates$GSP <- as.character(t.test_details_rec_rates$GSP)

# str(t.test_details_rec_rates$GSP)

t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(GSP_Rec_both_p = case_when(
    GSP == "GSP"  & rec_rate_approx_p == "approx_rec_rate" ~ "both",
    is.na(GSP)            & rec_rate_approx_p == "approx_rec_rate" ~ "rec_rate",
    GSP == "GSP"  & is.na(rec_rate_approx_p) ~ "GSP",
    TRUE ~ "other"
  ))


### difference between N rec and N applied
# names(t.test_details_rec_rates)

t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(diff_n_rec_applied = abs(Total_sum_N_content- Rec_N_jax))

closest_match_n <-t.test_details_rec_rates %>%
  group_by(Zone_ID) %>% 
  summarise(closest_match_n = min(diff_n_rec_applied))


#Add this back in


t.test_details_rec_rates <- left_join(t.test_details_rec_rates, closest_match_n)
# str(t.test_details_rec_rates)
t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(rec_rate_approx_n =
           case_when(
             closest_match_n == diff_n_rec_applied ~ "approx_rec_rate"))



t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  mutate(GSP_Rec_both_n = case_when(
    GSP == "GSP"  & rec_rate_approx_n == "approx_rec_rate" ~ "both",
    is.na(GSP)            & rec_rate_approx_n == "approx_rec_rate" ~ "rec_rate",
    GSP == "GSP"  & is.na(rec_rate_approx_n) ~ "GSP",
    TRUE ~ "other"
  ))








#### arrange the data so that I have the order of detail that reflects it.
# names(t.test_details_rec_rates)
t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  dplyr::select(

#Tier 1
Paddock_ID,
Strip_Type,
Organisation,
Contact,
Farmer,
Paddock_tested,
rainfall_class,
AGROECOLOG,

#Tier 2
Zone_ID,
Total_N,
Colwell,
DGT,
PBI,
p_rec,
maxN,
Rec_N_jax,
#p_rec_jax,
 
#Tier 3
Rate,
GSP,
Total_sum_N_content,
Total_sum_P_content,
Yld,
P_value,
Mean_diff,
rounded,
Significant,

#Tier 3 details# 
diff_p_rec_applied,
closest_match_p,
rec_rate_approx_p,
GSP_Rec_both_p,
diff_n_rec_applied,
closest_match_n,
rec_rate_approx_n,
GSP_Rec_both_n
)    



##############################################################################
### add some GM to yld results 
##############################################################################
# convert the yield to income of grain $/ha
# this assumes that all yield is in t /ha 
# all crops are wheat
# the 5 year wheat average is $286 and is same for all sites.

t.test_details_rec_rates <- t.test_details_rec_rates %>% mutate(grain_income = Yld * 286)

##############################################################################
## cost for test $3 per ha for rates the approx rate here some GSP are also approx rec rate labelled as both

# names(t.test_details_rec_rates)
# unique(t.test_details_rec_rates$GSP_Rec_both_p)
# unique(t.test_details_rec_rates$GSP_Rec_both_n)

t.test_details_rec_rates <- t.test_details_rec_rates %>% mutate(cost_test = case_when(
  GSP_Rec_both_p == "rec_rate" ~ 3.00,
  GSP_Rec_both_p == "both" ~ 3.00,
  
  GSP_Rec_both_n == "rec_rate" ~ 3.00,
  GSP_Rec_both_n == "both" ~ 3.00,
  TRUE ~ 0.00))

## cost fert is based on rainfall class - define the rainfall class

t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  dplyr::mutate(
    variable_costs = case_when(
      Strip_Type == "P Strip" & rainfall_class == "low" ~     194,
      Strip_Type == "P Strip" & rainfall_class == "medium" ~  358,
      Strip_Type == "P Strip" & rainfall_class == "high" ~    540,
      
      Strip_Type == "N Strip" & rainfall_class == "low" ~     220,
      Strip_Type == "N Strip" & rainfall_class == "medium" ~  340,
      Strip_Type == "N Strip" & rainfall_class == "high" ~    498))

### I don't get this step but it converts N applied from kg/ha to cost of N $ha
# str(t.test_details_rec_rates)
t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  dplyr::mutate(
    Cost_P_N_dollar_ha  = case_when(
      Strip_Type == "P Strip"  ~     Total_sum_P_content * 2.9,
      Strip_Type == "N Strip"  ~     Total_sum_N_content * 1.1))     

## GM
#GM = Income grain – cost test – variable cost – cost of N


t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  dplyr::mutate(
    total_cost = cost_test + variable_costs + Cost_P_N_dollar_ha,
    GM  = grain_income - total_cost)

# names(t.test_details_rec_rates)
all_step_t.test_details_rec_rates <- t.test_details_rec_rates
neat_t.test_details_rec_rates <- t.test_details_rec_rates %>% 
  dplyr::select(-diff_p_rec_applied,
                -diff_n_rec_applied,
                -closest_match_p,
                -closest_match_n,
                -grain_income,
                -cost_test,
                -variable_costs,
                -Cost_P_N_dollar_ha,
                -total_cost  )

# write.csv(neat_t.test_details_rec_rates, "W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/GM_t.test_details_rec_rates2019.csv")



All_zone_rates_2019 <-neat_t.test_details_rec_rates


# All_zone_rates_2019 <- read.csv("W:/value_soil_testing_prj/Yield_data/2020/processing/processing_files/for_econmics/GM_t.test_details_rec_rates2019.csv")


```


For P trials in 2019
The number of paddocks with either 1, 2,3 zones
How many paddocks have a N rec rate in zone 1 vs zone 2 that is higher than 5 kg


```{r rec rates different in zone 2019 P , echo=FALSE, message=TRUE, warning=FALSE}

## pull out P strip only, only keep zone data
P_zones_2019 <- All_zone_rates_2019 %>% 
  filter(Strip_Type == "P Strip") %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:maxN)


# for each paddocks what is the max and min P rec (doesnt matter how many zones)
Zone_In_Paddocks_P_2019 <- P_zones_2019 %>%  group_by(Paddock_ID) %>% 
  summarise(count_zone = n(),
            max_P_rec = max(p_rec, na.rm = FALSE),
            min_P_rec = min(p_rec, na.rm = FALSE))

#difference between high and low
Zone_In_Paddocks_P_2019 <- Zone_In_Paddocks_P_2019 %>% 
  mutate(diff_P_rec_rate = max_P_rec - min_P_rec)

#is the difference greater than 5 then it gets a value of 1
Zone_In_Paddocks_P_2019 <- Zone_In_Paddocks_P_2019 %>% 
  mutate(count_of_diff = case_when(
    count_zone >1 & diff_P_rec_rate >5 ~ 1,
    TRUE ~ 0))
#count how many paddocks have zones with different rec rate that is greater than 5
Zone_In_Paddocks_P_2019 %>%  group_by(count_zone) %>% 
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE))

Zone_In_Paddocks_P_2019 %>%  
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE),
            count =  n(),
            percent_zone_with_diff_rec_P = (sum_of_when_diff/count) *100)


```

For P trials in 2019
The number of paddocks with either 1, 2,3 zones
How many paddocks have a N rec rate in zone 1 vs zone 2 that is higher than 10 kg


```{r rec rates different in zone 2019 N , echo=FALSE, message=TRUE, warning=FALSE}
## pull out N strip only, only keep zone data
N_zones_2019 <- All_zone_rates_2019 %>% 
  filter(Strip_Type == "N Strip") %>% 
  distinct(Zone_ID, .keep_all = TRUE) %>% 
  dplyr::select(Paddock_ID:Rec_N_jax )


# for each paddocks what is the max and min N rec (doesnt matter how many zones)
Zone_In_Paddocks_N_2019 <- N_zones_2019 %>%  group_by(Paddock_ID) %>% 
  summarise(count_zone = n(),
            max_N_rec = max(Rec_N_jax , na.rm = FALSE),
            min_N_rec = min(Rec_N_jax , na.rm = FALSE))

Zone_In_Paddocks_N_2019 <- Zone_In_Paddocks_N_2019 %>% 
  mutate(diff_N_rec_rate = max_N_rec - min_N_rec)

#is the difference greater than 10 then it gets a value of 1
Zone_In_Paddocks_N_2019 <- Zone_In_Paddocks_N_2019 %>% 
  mutate(count_of_diff = case_when(
    count_zone >1 & diff_N_rec_rate >10 ~ 1,
    TRUE ~ 0))

#count how many paddocks have zones with different rec rate that is greater than 10
Zone_In_Paddocks_N_2019 %>%  group_by(count_zone) %>% 
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE))

Zone_In_Paddocks_N_2019 %>%  
  summarise(sum_of_when_diff = sum(count_of_diff, na.rm = TRUE),
            count =  n(),
            percent_zone_with_diff_rec_N = (sum_of_when_diff/count) *100)


```



## Details on the soil test, recommend rates and the average GSP

### 2019 data 

This data set is not great.
I have patchy records for the fertiliser applied and how much was applied over the season.

Therese has done a lot of work here but some sites just don't seem to add up.
A variety of problems, I have used her work as a cross reference.


I have done the N rec rates again and P rec rates - waiting for Sean to confirm rates cals are correct



```{r GSP recom rates for zone 2019 P, echo=FALSE, message=TRUE, warning=FALSE}

## pull out P strip only that has GSP, only keep zone data
P_zones_2019_GSP_rec_rate <- All_zone_rates_2019 %>%
  filter(Strip_Type == "P Strip") %>%
  filter(GSP == "GSP") %>%
  dplyr::select(Paddock_ID, 
                Zone_ID, 
                #Total_N,
                Colwell,
                DGT,
                PBI,
                p_rec,
                #Rec_N_jax,
                GSP,
                #Total_sum_N_content,
                Total_sum_P_content,
                rainfall_class 
                ) %>%
  distinct(Zone_ID, .keep_all = TRUE)

P_zones_2019_GSP_rec_rate$rainfall_class <- factor(P_zones_2019_GSP_rec_rate$rainfall_class, 
                                                            levels = c("low", "medium", "high"))


P_zones_2019_GSP_rec_rate %>%  group_by(rainfall_class) %>%
  summarise(Av_P_Colwell = mean(Colwell, na.rm = TRUE),
            Av_P_DGT = mean(DGT, na.rm = TRUE),
            Av_P_PBI = mean(PBI, na.rm = TRUE),
            
            Av_P_rec_rate = mean(p_rec, na.rm = TRUE),
            #median_N_rec_rate = median(Rec_N_jax, na.rm = TRUE),
            
            Av_P_GSP = mean(Total_sum_P_content, na.rm = TRUE),
            #median_N_GSP = median(Total_sum_P_content, na.rm = TRUE)
  )

```

```{r r GSP recom rates for zone 2019 N , echo=FALSE, message=TRUE, warning=FALSE}

N_zones_2019_GSP_rec_rate <- All_zone_rates_2019 %>%
  filter(Strip_Type == "N Strip") %>%
  filter(GSP == "GSP") %>%
  dplyr::select(Paddock_ID, 
                Zone_ID, 
                Total_N,
                #Colwell,
                #DGT,
                #PBI,
                Rec_N_jax,
                GSP,
                Total_sum_N_content,
                #Total_sum_P_content,
                rainfall_class 
                ) %>%
  distinct(Zone_ID, .keep_all = TRUE)
N_zones_2019_GSP_rec_rate$rainfall_class <- factor(N_zones_2019_GSP_rec_rate$rainfall_class, 
                                                            levels = c("low", "medium", "high"))

N_zones_2019_GSP_rec_rate %>%  group_by(rainfall_class) %>%
  summarise(Av_N_Total_N = mean(Total_N, na.rm = TRUE),
            Av_N_rec_rate = mean(Rec_N_jax, na.rm = TRUE),
            Av_N_GSP = mean(Total_sum_N_content, na.rm = TRUE)
  ) 
```

### 2020 data



```{r GSP recom rates for zone 2020 P, echo=FALSE, message=TRUE, warning=FALSE}

## pull out P strip only that has GSP, only keep zone data
P_zones_2020_GSP_rec_rate <- All_zone_rates_2020 %>%
  filter(Strip_Type == "P Strip") %>%
  filter(GSP == "GSP") %>%
  dplyr::select(Paddock_ID, 
                Zone_ID, 
                #Total_N,
                Colwell,
                DGT,
                PBI,
                p_rec,
                #Rec_N_jax,
                GSP,
                #Total_sum_N_content,
                Total_sum_P_content,
                rainfall_class 
                ) %>%
  distinct(Zone_ID, .keep_all = TRUE)

P_zones_2020_GSP_rec_rate$rainfall_class <- factor(P_zones_2020_GSP_rec_rate$rainfall_class, 
                                                            levels = c("low", "medium", "high"))


P_zones_2020_GSP_rec_rate %>%  group_by(rainfall_class) %>%
  summarise(Av_P_Colwell = mean(Colwell, na.rm = TRUE),
            Av_P_DGT = mean(DGT, na.rm = TRUE),
            Av_P_PBI = mean(PBI, na.rm = TRUE),
            Av_P_rec_rate = mean(p_rec, na.rm = TRUE),
            Av_P_GSP = mean(Total_sum_P_content, na.rm = TRUE)
           
  )

```




The yield difference for the 2019.
Oh boy this data is a mess - have stared here and there - multiple changes.
The first bit of code is just getting the data set ready.

(if you need to unpack it more scrap_notes4_2019 script is good to use)



```{r r GSP recom rates for zone 2020 N , echo=FALSE, message=TRUE, warning=FALSE}

N_zones_2020_GSP_rec_rate <- All_zone_rates_2020 %>%
  filter(Strip_Type == "N Strip") %>%
  filter(GSP == "GSP") %>%
  dplyr::select(Paddock_ID, 
                Zone_ID, 
                Total_N,
                #Colwell,
                #DGT,
                #PBI,
                Rec_N_jax,
                #p_rec_jax,
                GSP,
                Total_sum_N_content,
                #Total_sum_P_content,
                rainfall_class 
                ) %>%
  distinct(Zone_ID, .keep_all = TRUE)
N_zones_2020_GSP_rec_rate$rainfall_class <- factor(N_zones_2020_GSP_rec_rate$rainfall_class, 
                                                            levels = c("low", "medium", "high"))

N_zones_2020_GSP_rec_rate %>%  group_by(rainfall_class) %>%
  summarise(Av_N_Total_N = mean(Total_N, na.rm = TRUE),
            Av_N_rec_rate = mean(Rec_N_jax, na.rm = TRUE),
            Av_N_GSP = mean(Total_sum_N_content, na.rm = TRUE)
  ) 

```

The next step is getting the yield and GM and plot.
what is the yield difference between the approx rec rate and GSP for N and P and the 2 years

```{r stuff around GM respose for 2019 paddocks vs GSP, message=TRUE, warning=FALSE, include=FALSE}

 
  


```


Plots of the 2019 data

```{plots of GM r rec rates vs GSP 2019, echo=FALSE, message=TRUE, warning=FALSE}


```



2020 data set

```{r stuff around GM respose for 2020 paddocks vs GSP, message=TRUE, warning=FALSE, include=FALSE}





```